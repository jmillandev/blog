<!doctype html><html lang=es-es><head><title>| Jesús Millán</title><meta charset=utf-8><meta name=language content="en"><meta name=description content><meta name=keywords content><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content><meta name=twitter:site content="@jmillandev"><meta name=twitter:creator content="https://twitter.com/jmillandev"><link rel="shortcut icon" type=image/png href=/favicon.ico><link type=text/css rel=stylesheet href=/jmillandev.github.io/css/post.min.2cb93c91050d1853bf971cc31e00122edd6e0f405aa1de3b7f8ef67ea3b5a79a.css integrity="sha256-LLk8kQUNGFO/lxzDHgASLt1uD0Baod47f472fqO1p5o="><link type=text/css rel=stylesheet href=/jmillandev.github.io/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/\/jmillandev.github.io\/apuntes\/good-practices\/","name":"","author":{"@type":"Person","name":""},"description":""}</script></head><body><div class=burger__container><div class=burger aria-controls=navigation aria-label=Menu><div class="burger__meat burger__meat--1"></div><div class="burger__meat burger__meat--2"></div><div class="burger__meat burger__meat--3"></div></div></div><nav class=nav id=navigation><ul class=nav__list><li><a href=/jmillandev.github.io/>About</a></li><li><a class=active href=/jmillandev.github.io/apuntes/>Apuntes</a></li><li><a href=/jmillandev.github.io/blog/>Blog</a></li></ul></nav><main><style>@media(min-width:1024px){.post{width:85%;margin:0 auto;max-width:100%}}</style><div class=flex-wrapper><div class=post__container><div class=post><header class=post__header><h1 id=post__title></h1></header><article class=post__content><h1 id=a-quién-beneficia-contar-con-código-bien-escrito>¿A quién beneficia contar con código bien escrito?</h1><p>El código bien escrito beneficia a todos los involucrados en el proyecto.</p><ul><li><strong>A tí</strong>: Cuando retomemos un proyecto después de un largo tiempo nos beneficiará ya que sabremos cómo está ordenado y cómo está escrito todo.</li><li><strong>A cualquiera</strong>: Cualquier persona que deba modificar el código después de tí.</li><li><strong>A tu cliente</strong>: Aunque nunca lo sabrá, su negocio estará mejor atendido.</li></ul><h1 id=elementos-dotan-de-calidad-al-código>Elementos dotan de calidad al código:</h1><ul><li><a href=#legibilidad>Legibilidad</a>: qué tan fácil es interpretar lo que el código dice.</li><li><a href=#mantenibilidad>Mantenibilidad</a>: cuánto esfuerzo supondrá adaptar el código a nuevos requerimientos.</li><li>Testeabilidad: cuánto esfuerzo supondrá realizar pruebas sobre este código.</li></ul><p><a name=legibilidad></a></p><h2 id=legibilidad>Legibilidad<a class=anchor href=#legibilidad>#</a></h2><p>El código fuente lo escribimos para personas como tú y yo, para las computadoras tenemos las versiones compiladas.</p><p>Debemos seguir un estándar de codificación, el cual nos ayuda a:</p><ul><li>Generar código claro y consistente.</li><li>Evitar perder tiempo en decisiones triviales.</li></ul><h3 id=acoplate-a-un-estandar>Acoplate a un estandar<a class=anchor href=#acoplate-a-un-estandar>#</a></h3><p>Un estandar de codificacion es una seria de reglas que indica como debes escribir el codigo. Como por ejemplo ¿Donde deben inicar las lleves de un bloque de codigo?, ¿ cuantas lineas de separacion hay entre los bloques?, ¿Cual es la sintaxis para la creacion de variables?, etc.</p><ol><li>**Define un estándar:**Piénsalo una vez y déjalo por escrito.</li></ol><p><strong>NOTA:</strong> Puede ser el del lenguaje que se esta manejando, normalmente esta documentado en la web del lenguaje de programacion.</p><ol start=2><li><p><strong>Respétalo:</strong> Haz un esfuerzo por adherirte al estándar durante tu día a día.</p></li><li><p><strong>Apóyate en algún linter:</strong> Esta sencilla herramienta te ayudará a incorporar buenas prácticas.</p></li></ol><h3 id=identificadores-mnemotécnicos-específicos-y-precisos>Identificadores: mnemotécnicos, específicos y precisos<a class=anchor href=#identificadores-mnemotécnicos-específicos-y-precisos>#</a></h3><p>Los identificadores son variables, funciones, clases, módulos, componentes, etc. Elementos a los que nosotros debamos crearles un nombre propio.</p><p>Ejemplo sin un identificador mnemotécnico una función se vería así:</p><pre><code class=language-php>function f( int $b, int $a ) : float {
        return ( $b * $a ) / 2;
}
</code></pre><p>Al leer este código no sabemos para qué funciona y hasta podríamos borrarlo por equivocación.</p><p>Ahora utilizando un identificador mnemotécnico se vería así:</p><pre><code class=language-php>function areaTriangulo( int $base, int $altura ) : float {
        return ( $base * $altura ) / 2;
}
</code></pre><p>Ahora gracias a que el código es más legible sabemos para qué funciona esta función.</p><p>Atención a los identificadores que estableces: Un buen indicador es pedirle a alquien que trabaje contigo que lea el codigo y que te diga que hace.</p><p><a name=mantenibilidad></a></p><h2 id=mantenibilidad>Mantenibilidad<a class=anchor href=#mantenibilidad>#</a></h2><h3 id=código-modular>Código modular<a class=anchor href=#código-modular>#</a></h3><p>El código modular son pedazos de códigos divididos(normalmente en funciones) que pueden ser utilizados en cualquier lugar para evitar tener un solo archivo con un bloque de código gigante.</p><p>Bloques de codigo potenciales para modularizar:</p><ul><li>Aquellos que estan dentro de un bucle.</li><li>Los que estan dentro de un condicional.</li><li>Codigo que realice calculos o metodos complejos.</li><li>Codigo que se repita/realice con frecuencia.</li></ul><h3 id=codigo-reutilizable>Codigo reutilizable<a class=anchor href=#codigo-reutilizable>#</a></h3><p>Escribir código reutilizable nos va a ayudar a que en lugar de copiar y pegar una misma línea de código pero con diferentes parámetros lo hagamos a través de una función que retorne los valores que necesitamos y luego la podremos llamar en cualquier lugar del código que necesitemos pasándole los parámetros que deseamos.</p><h3 id=código-organizado>Código organizado<a class=anchor href=#código-organizado>#</a></h3><p>El código organizado se refiere a cómo tenemos distribuido nuestros archivos en la raíz (root) del proyecto. A mayor organización, mayor entendimiento del código.
Usualmente lo que haremos es agrupar los archivos que tengan contenido similar en directorios que tengan sentido. Ejemplo:</p><p>Convencion de distribucion de archivos en PHP moderno:</p><pre><code>/public
/src
/tests
/vendor    
</code></pre><p><strong>Directorios</strong></p><ul><li><strong>public</strong>: Contiene todos los documentos que son accesibles desde afuera del servidor.</li><li><strong>src</strong>: Contiene todos los archivos propios de nuestro codigo fuente(nuestro proyecto).</li><li><strong>test</strong>: Pruebas a realizar.</li><li><strong>vendor</strong>: dependencias/librerias de terceros.</li></ul><h1 id=libre-de-vicios>Libre de vicios</h1><h2 id=evitar-el-hardcoding>Evitar el hardcoding<a class=anchor href=#evitar-el-hardcoding>#</a></h2><p>El hardcoding es la práctica de escribir <em>valores literales</em> en lugar de <em>identificadores</em>. <strong>NO debe de usarse</strong>, ya que si el día de mañana debemos cambiar los valores eso significa que debemos cambiar el código en los lugares que esté ese valor estático por completo y luego mandar a producción, cuándo podríamos hacer el cambio más orgánico en una variable que afecte a todos los lugares que es llamada. Para esto utilizamos variables de configuracion o variables de entorno, es decir variables que son exernas al codigo fuente de nuestro programa.</p><h2 id=evitar-efectos-colaterales>Evitar efectos colaterales<a class=anchor href=#evitar-efectos-colaterales>#</a></h2><p>Los efectos colaterales en este caso son aquellos que suceden mas alla del codigo que se esta leyendo. Debemos analizar muy bien nuestro código para evitar efectos colaterales y evitar que nuestro código deje de funcionar.
<strong>Consejos:</strong></p><ul><li><strong>No</strong> uses variables globales.</li></ul><h1 id=principios-solid>Principios SOLID</h1><p><strong>SOLID</strong> son cinco principios básicos de la programación orientada a objetos que ayudan a crear software mantenible en el tiempo.</p><p><strong>SOLID</strong> significa:</p><ul><li><a href=#single>S</a>: Single Reponsibility Principle.</li><li><a href=#open>O</a>: Open/Closed Principle.</li><li><a href=#liskov>L</a>: Liskov Substitution Principle.</li><li><a href=#interface>I</a>: Interface Segregation Principle.</li><li><a href=#dependency>D</a>: Dependency Inversion Principle.</li></ul><p><a name=ingle></a></p><h2 id=single-reponsibility-principle>Single Reponsibility Principle<a class=anchor href=#single-reponsibility-principle>#</a></h2><p>A class should have one and only one reason to change. Meaning that a class should have only one job.</p><p>En español:
Una clase que debe tener sólo una razón para cambiar. Es decir, que cada clase debe tener una UNICA responsabilidad.</p><p>Veamos un Ejemplo:</p><pre><code class=language-java>package main;

public class Rectangulo {
    private float base;
    private float altura;

    public Rectangulo(float base, float altura) {
        this.setBase(base);
        this.setAltura(altura);
    }

    public float getBase() {
        return this.base;
    }

    public void setBase(float base) {
        this.base = base;
    }

    public float getAltura() {
        return this.altura;
    }

    public void setAltura(float altura) {
        this.altura = altura;
    }
    
    public String toString() {
        return &quot;Base &quot; + this.base + &quot;, Altura &quot; + this.altura;
    }

    public float area() {
        return this.base * this.altura;
    }

    // Este metodo No cumple con el principio de responsabilidad unica
    public void imprimir() {
        System.out.println(this);
    }

}
</code></pre><p>En el ejemplo anterio, a excepción del metodo &lsquo;imprimir&rsquo;, toda la clase cumple con el principio de responsabilidad unica. Debido a que sus metodos estan fuertemente relacionado(tienen una alta cohesión), donde la pregunta principal podria ser: ¿que se tiene que mostrar?.</p><p>Pero si nos centramos en el metodo &lsquo;imprimir&rsquo;, este se podria decir que pertenece a otra capa en la logica. La capa de presentación(donde la pregunta seria ¿como mostrar la información?), ya que si en un futuro, queremos mostrar el contenido de esta clase en un formato Json en un servicio WEB, no deberiamos modificar la clase. Entoces, aplicando el principio de responsabilidad unica creariamos otra clase que se veria asi:</p><pre><code class=language-java>package main;

public class Presentacion {
    public void imprimir(Rectangulo rectangulo) {
        System.out.println(restantgulo);
    }

    public void area(Rectangulo rectangulo) {
        System.out.println(restantgulo.area());
    }
}
</code></pre><p><a name=open></a></p><h2 id=openclosed-principle>Open/Closed Principle<a class=anchor href=#openclosed-principle>#</a></h2><p>Objects or entities should be open for extension, but closed for modification.</p><p>En español:
Establece que una entidad de software debe quedarse abierta para su extensión, pero cerrada para su modificación.</p><p>Es decir, las entidades, clases, metodos deben quedar abierta al posibilidad de extension, de esta forma la clase puede adaptarse a nuevos ecenarios sin la necesidad de modificar o añadir codigo. Este principio suele resolverse delegando las funcionalidades( usualmente mediante la herencia y/o interfaces).</p><p>Ejemplo:</p><p><strong>Violacion_O/C</strong>: Aqui vemos como la funcion valida el tipo de documento que se desea procesar, de esta manera seria imposible agregar un nuevo estilo de documento sin modificar el archivo</p><pre><code class=language-php>&lt;?php

class DocProcessor
{
        public function process( array $docs )
        {
                foreach ( $docs as $doc ) {
                        if ( $doc instanceof Invoice ) {
                                $doc-&gt;sendToClient();
                        } elseif ( $doc instanceof Receipt ) {
                                $doc-&gt;archive();
                        } elseif ( $doc instanceof Memo ) {
                                $doc-&gt;markAsRead();
                        }
                }
        }
}
</code></pre><p><strong>O/C_Respetado</strong>: En este cado el metodo se encarga de procesar directamente el archivo, delegando la responsabilidad de validar el archivo a otra clase.</p><pre><code class=language-php>&lt;?php

class DocProcessor
{
        public function process( array $docs )
        {
                foreach ( $docs as $doc ) {
                        $doc-&gt;process(); 
                }
        }
}
</code></pre><p>Otro ejemplo:
Volamos un instante con el codigo de ejemplo en <a href=#open>Open/Closed Principle</a> y regresemos aca.
Supongamos que creamos otra clase llamado Triangulo, que hace algo muy similar a la clase Rectangulo, esta calcula el area de dicha figura.</p><p>Pero, ¿que pasa si ahora queremos imprimir el area del triangulo?. Deberiamos hacer algo asi en la clase &lsquo;Presentación&rsquo;</p><pre><code class=language-java>package main;

public class Presentacion {
    public void imprimir(Rectangulo rectangulo) {
        System.out.println(rectantgulo);
    }

    public void area(Rectangulo rectangulo) {
        System.out.println(rectantgulo.area());
    }

    public void imprimir(Triangulo triangulo) {
        System.out.println(triangulo);
    }

    public void area(Triangulo triangulo) {
        System.out.println(triangulo.area());
    }

}
</code></pre><p>Este codigo funciona perfectamente, pero supone una violación al princio O/C. Ya qeu tendiramos que crear N*2 metodos por cada n figuras que tengamos. Para solucionar esto podemos crear la siguiente interfaz.</p><pre><code class=language-java>package main;

public class IFigura {

    float area();

}
</code></pre><p>Luego de aplicar dicha interfaz a nuestras dos clases(Triangulo y Rectangulo). Podriamos hacer un refactor a nuestra clase &lsquo;Presentacion&rsquo; y quedaria así:</p><pre><code class=language-java>public class Presentacion {
    public void imprimir(IFigura figura) {
        System.out.println(figura);
    }

    public void area(IFigura figura) {
        System.out.println(figura.area());
    }

}
</code></pre><p>De esta forma dejamos nuestro codigo abiarto a la extension pero cerrado a la modificación.</p><p><a name=liskov></a></p><h2 id=liskov-substitution-principle>Liskov Substitution Principle<a class=anchor href=#liskov-substitution-principle>#</a></h2><p>Let q(x) be a property provable about objects of x of tiye T. Then q(y) should provable for objects y of type S where S is a subtype of T.</p><p>Es decir:
Establece que cada clase que hereda de otra puede usarse como su padre sin necesidad de conocer las diferencias entre ellas. Para que pueda darse este principio debe cumplir con dos puntos:</p><ul><li>El cliente debe usar métodos de la clase padre únicamente.</li><li>La clase hija no debe alterar el comportamiento de los métodos de la clase padre.</li></ul><p><strong>Consejos</strong>
En el caso de que una clase hija requiera modificar el codigo de un metodo de la clase padre, vale la pena preguntarse ¿Estas clases deben estar relacionados hereditariamente?, lo mas seguro es que la respuesta sea no, y mantengan otro tipo de relacion.</p><p><a name=interface></a></p><h2 id=interface-segregation-principle>Interface Segregation Principle.<a class=anchor href=#interface-segregation-principle>#</a></h2><p>Establece que los clientes de un programa cuando implementan una interface sólo deberían conocer de éste los métodos que realmente usan. Es decir, no deben implementar interfaces con metodo que no utilizan en su codigo fuente.</p><p><strong>Consejos</strong>
A client should never be forced to implement an inaterface that it doesn&rsquo;t use or client shouln&rsquo;t be forced to depend on methods they do not use.</p><p>En el caso de que tengas un metodo implementando interfaces con metodos que este no utilizara(o seria estupido que los utilizara), debemos &ldquo;partir&rdquo; la interfaz en varias interfaces(posiblemente que vayan heredando unas de otras). Tambien recordemos que una misma clase puede implementar varias interfaces.</p><p><a name=dependency></a></p><h2 id=dependency-inversion-principle>Dependency Inversion Principle.<a class=anchor href=#dependency-inversion-principle>#</a></h2><p>Entities must depend on abstractions not on concretions. It states that the high level madule must not depend on the low level module, but they should depend on abtractions.</p><p>Detalla que los módulos de alto nivel no deben depender de los de bajo nivel, ambos deben depender de abstracciones. Es decir, los objetos no deben ser creados dentro de las clases sino pasados como parametro. Y a su vez estos parametros no deben ser de un tipo de clase en especial, sino que deberan depender de un interfaz.</p><p>Las abstracciones no deben depender de los detalles, los detalles deben depender de las abstracciones.</p><p>Para entender lo antes dicho definamos las clases de alto y bajo nivel:</p><ol><li><strong>Clases de alto nivel:</strong></li></ol><p>Son aquellas que tienen que ver con la logica de negocio. Con la aplicacion especifica que se esta desarrollando.</p><ol start=2><li><em>Clases de bajo nivel:</em></li></ol><p>Son aquellas que existen con el proposito de ayudar a las clases de alto nivel a cumplir su cometido.</p><h1 id=patrones-de-diseño>Patrones de Diseño</h1><p>Los patrones de diseño son soluciones de arquitectura de software aplicables a diferentes problemas. Estos son soluciones conceptuales que se pueden aplicar a la hora de pensar como diseñar las clases.</p><p>Basicamente existen 3 tipos:</p><ol><li><a href=#creacionales><strong>Creacionales:</strong></a> Nos hablan de como se crean nuevas instancias de los objetos.</li></ol><p>Entre ellos encontramos:</p><ul><li><a href=#abstract_factory><em>Abstract Factory</em></a>: Provee una interfaz para la creacion de familias de objetos sin espeficicar una clase en concreto.</li><li><a href=#builder><em>Builder</em></a>: Separa la construccion de objectos complejos.</li><li><a href=#factory_method><em>Factory Method</em></a>: Define un interfaz para la creacion de un objecto pero deja qu la subclase decida que clase instanciar.</li><li><a href=#prototype><em>Prototype</em></a>: especifica que tipo de objectos crear usando una instancia prototipo y crea nuevos objecos copiando este prototipo.</li><li><a href=#singleton><em>Singleton</em></a>: Nos aseguramos que una clase solo puede ser instanciada una vez, ademas de proveer un punto de acceso a esta.</li></ul><ol start=2><li><a href=#estructurales><strong>Estructurales:</strong></a> Nos hablan de como debemos estructurar nuestras clases para crear estructuras flexibles y eficientes.</li></ol><p>Entre ellos encontramos:</p><ul><li><a href=#adapter><em>Adapter</em></a>: Convierte la interaz de una clase en otro interfaz quee cliente espera.</li><li><a href=#bridge><em>Bridge</em></a>: Nos permite desacoplar un a abstracción de su implementacion, de manera que ambas puedan ser modificadas indepedientemente sin necesdad de alterar por ello la otra.</li><li><a href=#composite><em>Composite</em></a>: sirve para construir objetos complejos a partir de otros más simples y similares entre sí, gracias a la composición recursiva y a una estructura en forma de árbol.</li><li><a href=#decorator><em>Decorator</em></a>: Agrega responsabilidades adicionales a un objeto de forma dinámica.</li><li><a href=#facade><em>Facade</em></a>: Nos permite utilizar módulos complejos de una forma sencilla y con bajos costos para el cliente.</li><li><a href=#flyweight><em>Flyweight</em></a>: Nos permite eliminar o reducir redundancia cuando trabajamos con una gran cantidad de objetos.</li><li><a href=#proxy><em>Proxy</em></a>: Permite controlar el acceso a diferentes áreas de módulos.</li></ul><ol start=3><li><a href=#comportamiento><strong>De Comportamiento:</strong></a> Hablan sobre como deben comportarse nuestros objetos. Gestionando algoritmos y responsabilidades entre ellos.</li></ol><p>Entre ellos encontramos:</p><ul><li><a href=#chain_of_responsability><em>Chain of Responsibility</em></a>: Evita acoplar el emisor de una petición a su receptor dando a más de un objeto la posibilidad de responder a una petición. Para ello, se encadenan los receptores y pasa la petición a través de la cadena hasta que es procesada por algún objeto.</li><li><a href=#command><em>Command</em></a>: Permite solicitar una operación a un objeto sin conocer realmente el contenido de esta operación, ni el receptor real de la misma. Para ello se encapsula la petición como un objeto, con lo que además facilita la parametrización de los métodos.</li><li><a href=#interpreter><em>Interpreter</em></a>: Dado un idioma, define una representación para su gramática junto con un intérprete que use la representación para interpretar oraciones en el lenguaje.</li><li><a href=#iterator><em>Iterator</em></a>: Define una interfaz que declara los métodos necesarios para acceder secuencialmente a un grupo de objetos de una colección.</li><li><a href=#mediator><em>Mediator</em></a>: Define un objeto que encapsula cómo un conjunto de objetos interactúan.</li><li><a href=#memento><em>Memento</em></a>: Permite almacenar el estado de un objeto (o del sistema completo) en un momento dado de manera que se pueda restaurar en ese punto de manera sencilla. Para ello se mantiene almacenado el estado del objeto para un instante de tiempo en una clase independiente de aquella a la que pertenece el objeto (pero sin romper la encapsulación), de forma que ese recuerdo permita que el objeto sea modificado y pueda volver a su estado anterior.</li><li><a href=#observer><em>Observer</em></a>: Define una dependencia del tipo uno a muchos entre objetos, de manera que cuando uno de los objetos cambia su estado, notifica este cambio a todos los dependientes.</li><li>[<em>State</em>]: Se utiliza cuando el comportamiento de un objeto cambia dependiendo del estado del mismo.</li><li><a href=#template_method><em>Template Method</em></a>: Define el esqueleto de programa de un algoritmo en un método, llamado método de plantilla, el cual difiere algunos pasos a las subclases.</li><li><a href=#visitor><em>Visitor</em></a>: Representa una operación que se realiza sobre los elementos que conforman la estructura de un objeto.</li></ul><p><em><strong>IMPORTANTE:</strong></em> Es importante recalcar que los patrones de diseño son para darte una idea de como diseñar tu aplicacion, no son un &ldquo;copia y pega&rdquo; pues no siempre son la mejor solucion que se adapta a tu problema en algunas cosos puede ponerte las cosas mas dificiles.</p><h2 id=creacionales>Creacionales<a class=anchor href=#creacionales>#</a></h2><h3 id=simple-factory>Simple Factory<a class=anchor href=#simple-factory>#</a></h3><p>Este metodo perse, no es catalogado como un patron de diseño, sin embargo es necesario hablar de el para comprender mejor patrones como abstract factory o factory method.</p><p>La idea de este, es poder crear objetos complejos de una forma sencilla.</p><p>Por Ejemplo:
Supongamos que tenemos la siguiente clase:</p><pre><code class=language-python>class Pizza:

    def __init__(self, cantidad_rebanadas: int):
        self.cantidad_rebanadas = cantidad_rebanadas

    @property
    def cantidad_rebanadas(self):
        return self.cantidad_rebanadas

    def __str__(self):
        return f&quot;Cantidad de rebanadas: {self.cantidad_rebanadas}&quot;


class Pizzeria:
    &quot;&quot;&quot;
    Esta Clase nos ayudara con el proceso de crear una nueva pizza,
    por si tenemos que leer algo de la base de datos, Conectarnos con un
    API, o cualquier otro requerimiento en logica del negocio.
    &quot;&quot;&quot;
    small = 6
    medium = 8
    large = 12

    def create_small_pizza(self):
        return Pizza(self.small)

    def create_medium_pizza(self):
        return Pizza(self.medium)

    def create_large_pizza(self):
        return Pizza(self.large)


if __name__ == &quot;__main__&quot;:
# Si no implementamos Simple Factory, la instancia de la clase se veria como:
    pizzaMargarita = Pizza(8)

    print(pizzaMargarita)

# Implementando Simple Factory, la instancia de la clase se veria como:
    pizzeria = Pizzeria()
    pizzaPeperoni = pizzeria.create_medium_pizza()

    print(pizzaPeperoni)
</code></pre><h3 id=factory-method>Factory Method<a class=anchor href=#factory-method>#</a></h3><p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p><p>En español:
Define una interfaz para la creación de un objecto, pero deja que la subclase, es decir la clase que implementa la interfaz, decida que clase instanciar.</p><p>Esta patron nos permitira mediante una clase generar objectos complejos controlados. La diferencia con el Simple Factory es que aqui necesitaremos de una interfaz para poder crear dichos objectos.</p><p>Ejemplo:</p><pre><code class=language-java>public class Pizza {

	private int cantidadRebanadas;
	private String especialidad;
	
	public Pizza(int cantidadRebanadas, String especialidad) {
		this.cantidadRebanadas = cantidadRebanadas;
		this.especialidad = especialidad;
	}
	
	public String toString() {
		return &quot;Cantidad rebanadas : &quot; + this.cantidadRebanadas + &quot; Especilidad : &quot; + this.especialidad;
	}
	
}


public interface IPizzeria {

	Pizza crearPizza(String tipo);
	
}

public class PizzaOrillaRellena extends Pizza {

	public PizzaOrillaRellena(int cantidadRebanadas, String especialidad) {
		super(cantidadRebanadas, especialidad);
	}
	
}

public class PizzeriaCF implements IPizzeria {

	public Pizza crearPizza(String tipo) {
		
		if (tipo.equals(&quot;Peperoni&quot;)) {
			return new Pizza(8, &quot;Peperoni&quot;);
		}
		
		if (tipo.equals(&quot;Hawaiana&quot;)) {
			return new Pizza(8, &quot;Hawaiana&quot;);
		}
		
		if (tipo.equals(&quot;Peperoni orilla rellena&quot;)) {
			return new PizzaOrillaRellena(12, &quot;Peperoni&quot;); //
		}
		
		return null;
	}
	
}

public class Main {

	public static void main(String[] args) {
		
		PizzeriaCF cf = new PizzeriaCF();
		
		Pizza peperoni = cf.crearPizza(&quot;Peperoni&quot;);
		Pizza hawaiana = cf.crearPizza(&quot;Hawaiana&quot;);
		Pizza orillaRellena = cf.crearPizza(&quot;Peperoni orilla rellena&quot;);
		
		
		System.out.println(peperoni);
		System.out.println(hawaiana);
		
		System.out.println(orillaRellena);
		
	}

}
</code></pre><p>Como vemos en el ejemplo anterior es la clase <em>PizzeriaCF</em> mediando la interfaz <em>IPizzeria</em> la encargada de crear la instancia del tipo de Pizza requerida</p><h3 id=abstract-factory>Abstract Factory<a class=anchor href=#abstract-factory>#</a></h3><p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p><p>Una de las principales direfencia entre este patron y el Factory Method, es que acá nuestra intererfaz contendra N cantidad de metodos(Factories) para crear distintos objectos tipo de objectos(Con cierta relación entre si). Ejemplo:</p><pre><code class=language-java>public interface IAbstractFactory {

	IComputadora crearComputadora();
	
	ITablet crearTablet();
	
}

public interface IComputadora {

}

public interface ITablet {

}



public class MacbookPro implements IComputadora {

}

public class IPad implements ITablet {

}

public class AppleStore implements IAbstractFactory {

	public IComputadora crearComputadora() {
		return new MacbookPro();
	}
	
	public ITablet crearTablet() {
		return new IPad();
	}
	
}


public class QX410 implements IComputadora {

}

public class TabS3 implements ITablet {

}

public class SamsungStore implements IAbstractFactory {

	public IComputadora crearComputadora() {
		return new QX410();
	}
	
	public ITablet crearTablet() {
		return new TabS3();
	}
	
}



public class Main {

	public static void main(String[] args) {
		
		SamsungStore samsung = new SamsungStore();
		AppleStore apple = new AppleStore();
		
		IComputadora mac = apple.crearComputadora();
		ITablet ipad = apple.crearTablet();
		
		IComputadora qx = samsung.crearComputadora();
		ITablet s3 = samsung.crearTablet();
		
	}

}
</code></pre><p>En este caso nuestro AbstractFactory, Es la abtraccion de una tienda electronica, Donde solo espeficicamos los distintos FactoryMethod que alli se crean. Luego la subclase es la encargada de crear los distintos tipo de objectos.</p><h3 id=singleton>Singleton<a class=anchor href=#singleton>#</a></h3><p>Ensure a class only has one instance, and provide a global point of access to it.</p><p>Permite restringir la creación de objetos pertenecientes a una clase o al valor de un tipo a un único objeto. Dicho de otra manera la idea es tener <strong>una sola instancia</strong> de la clase a lo largo de toda nuestra aplicacion.
Ejemplo:</p><pre><code class=language-php>class Singleton
{
    private static $theInstance = null;
    public statis function getInstance(){
        if ( self::$theInstance === null ) {
            self::$theInstance = new sefl();
        }
        return self::$theInstance
    }
    privade function __contruct() {
        // code..
    }
}
</code></pre><p>Como acabamos de ver solo puede existir una instancia de esta clase durante la vida de esta aplicacion ya que esta puede ser creada solo desde dentro de ella misma, Y esta configurada para que al crearse por primera vez, no se vuelva a cronstruir.</p><p>La creación de este patron la podriamos resumir en los siguiente pasos.</p><ul><li>Hacer privado el metodo constructor de la clase, de esta manera solo desde la clase perse podra se ejecutado dicho metodo.</li><li>Crear un nuevo metodo <strong>estatico</strong> desde donde obtendermos la instancia de nuestra clase.</li><li>Validar desde nuestro nuevo metodo si ya existe o no una instancia creada(generarmente con un atributo privado), Si no existe, se crea y se retorna. Si existe, simplemente se retorna.</li></ul><p>Un ejemplo de creacion por el patron Singleton son los <em>log de errores</em> de las aplicaciones. Otro ejemplo muy comun, es el acceso a la base de datos.</p><h3 id=builder>Builder<a class=anchor href=#builder>#</a></h3><p>Separate the construction of a complex object from its representation so that the same construction process can create diferent representations.
This provides solution to Telescopic constructors and constructor overload.</p><p>Este metodo es muy util a la hora de crear objectos con atributos variables, como puede ser:</p><pre><code class=language-java>
package main;

public class Usuario {
	
	private String nombre;
	private String apellido;
	
	private boolean medioContacto; 
	
	private String email;
	private String telefono;
	private String direccion;
	
    //3. step: All setters modify it so that it returns the class object..
    // only Optional attributes have setters
	public BuilderUsuario setMedioContacto(boolean medioContacto) {
		
		if(!medioContacto) {
			throw new IllegalArgumentException(&quot;No es posible asiganar un valor falso a medio de contacto&quot;);
		}
		
		this.medioContacto = medioContacto;
		return new BuilderUsuario(this);
	}
    
    // 1 step: Constructor private!	
	private Usuario(String nombre, String apellido) {
		this.nombre = nombre;
		this.apellido = apellido;
		
		this.medioContacto = false;
		
		this.email = &quot;&quot;;
		this.telefono = &quot;&quot;;
		this.direccion = &quot;&quot;;
		
	}
	// 2 step: Generate a public and static method that allows us to return a new class object
	public static Usuario Make(String nombre, String apellido) {
		return new Usuario(nombre, apellido);
	}
	
    // 4 step: Method that returns the final object, the method is instance
	public Usuario Build() {
		return this;
	}
	
	public String toString() {
		return &quot; &quot; + this.nombre + &quot; &quot; + this.apellido + &quot; &quot; + this.email + &quot; &quot; + this.telefono + &quot; &quot; + this.direccion;
	}
	
	
	public static class BuilderUsuario{
		
		private Usuario usuario;
		
		public BuilderUsuario(Usuario usuario) {
			this.usuario = usuario;
		}
		
		public BuilderUsuario setDireccion(String direccion) {
			usuario.direccion = direccion;
			return this;
		}

		public BuilderUsuario setEmail(String email) {
			usuario.email = email;
			return this;
		}

		public BuilderUsuario setTelefono(String telefono) {
			usuario.telefono = telefono;
			return this;
		}
		
		public Usuario Build() {
			return usuario;
		}
	}
	
}

public class Main {

	public static void main(String[] args) {

		Usuario codi = Usuario.Make(&quot;Codi&quot;, &quot;Facilito&quot;)
							.setMedioContacto(false)
							.setDireccion(&quot;México&quot;).Build();
							
		System.out.println(codi);
	}

}

</code></pre><p>Veamos que hace este codigo:</p><ul><li>El metodo <strong>Make</strong>: crea el objeto mas basico(Este resive los parametros obligatorios).</li><li>El Metodo <strong>Build</strong>: Se encarga simplemente de retornar el objeto perse.</li><li>Setters: Se encargan de setear los valores opcionales y a su vez retornar un objeto. De tal forma que podemos seguir llamando a los metodos del objeto.</li><li>A su ves el setter setMedioContacto retorna un objecto del tipo <strong>BuilderUsuario</strong>, que es el que contiene los setter. Es metodo es totalmente customizado(No pertenece al patron perse). Se creo con la finalidad de que la unica manera de que le podamos seterar; El email, la direccion o el telefono a un usuario es que antes hayamos pasado por este &ldquo;Setter&rdquo; <em>setMedioCotacto</em>.</li></ul><p>Como vimos con este patron podemos ir creando objetos complejos, mediante &ldquo;partes&rdquo;, de esta manera podemos ir crear objetos con las partes que necesitemos y todo de una manera muy legible.</p><h3 id=prototype>Prototype<a class=anchor href=#prototype>#</a></h3><p>Specify the kinds of objects to create using a prototypical instance, and createnew objects by copying this prototype.</p><p>Es principalmente util cuando debemos crear varias instancias de un objeto pero con ligeras modificaciones. Ejemplo, los fantasmas en Pac-Man.
Otro caso donde es recomendable utilizar en la creacion de objectos donde uno o varios atributos tienen un costo significando(Como consultar a la DB o a una API).</p><p>Ejemplo en codigo:</p><pre><code class=language-java>package main;

public class Enemigo {

   private String imagen; 
   private int posX;
   private int posY;
   private int cantidadVida;
   
   public Enemigo(String imagen, int posX, int posY, int cantidadVida) {
       this.setImagen(imagen);
       this.setPosX(posX);
       this.setPosX(posX);
       this.setCantidadVida(cantidadVida);
   }
   
   public Enemigo(Enemigo enemigo) {
       this.setImagen(enemigo.getImagen());
       this.setPosX(enemigo.getPosX());
       this.setPosX(enemigo.getPosY());
       this.setCantidadVida(enemigo.getCantidadVida());
   }
   
   public Enemigo clone() {
       //return new Enemigo(this);
       return new Enemigo(this.imagen, this.posX, this.posY, this.cantidadVida);
   }
   
   public String getImagen() {
       return imagen;
   }
   
   public void setImagen(String imagen) {
       this.imagen = imagen;
   }
   
   public int getPosX() {
       return posX;
   }
   
   public void setPosX(int posX) {
       this.posX = posX;
   }
   
   public int getPosY() {
       return posY;
   }
   
   public void setPosY(int posY) {
       this.posY = posY;
   }
   
   public int getCantidadVida() {
       return cantidadVida;
   }

   public void setCantidadVida(int cantidadVida) {
       this.cantidadVida = cantidadVida;
   }
}

public class Main {

   public static void main(String[] args) {
       
       Enemigo enemigoBase = new Enemigo(&quot;Imagen1.png&quot;, 0, 100, 2);
       
       Enemigo enemigo1 = new Enemigo(enemigoBase);
       Enemigo enemigo2 = new Enemigo(enemigoBase);
       Enemigo enemigo3 = new Enemigo(enemigoBase);
       
       enemigo1.setPosX(100);
       enemigo2.setPosX(150);
       enemigo3.setPosX(200);
       
       Enemigo enemigoBase2 = new Enemigo(&quot;Imagen1.png&quot;, 0, 200, 2);
       
       Enemigo enemigo4 = enemigoBase2.clone();
       Enemigo enemigo5 = enemigoBase2.clone();
       Enemigo enemigo6 = enemigoBase2.clone();
       
       enemigo4.setPosX(100);
       enemigo5.setPosX(150);
       enemigo6.setPosX(200);
       
       
   }

}
</code></pre><h2 id=estructurales>Estructurales<a class=anchor href=#estructurales>#</a></h2><h3 id=adapter>Adapter<a class=anchor href=#adapter>#</a></h3><p>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn&rsquo;t otherwise because of incompatible interfaces.</p><p>Ejemplo:</p><pre><code class=language-java>public interface IConexionSQL {
	
	void conexion();
	
	String runQuery();
	
}

public interface IConexionNoSQL {
	
	void conexion();
	
	String excecuteSentence();
	
}

public class ConexionMySQL implements IConexionSQL {

	public void conexion() {
		System.out.println(&quot;Conexión con MYSQL&quot;);
	}
	
	public String runQuery() {
		return &quot;Consulta MYSQL&quot;;
	}
	
}

public class ConexionMongoDB implements IConexionNoSQL {
	
	public void conexion() {
		System.out.println(&quot;Conexión con MongoDB&quot;);
	}
	
	public String excecuteSentence() {
		return &quot;Consulta MongoDB&quot;;
	}
	
}

public class AdaptadorDB implements IConexionSQL {

	private IConexionNoSQL noSQL;
	
	public AdaptadorDB(IConexionNoSQL noSQL) {
		this.noSQL = noSQL;
	}
	
	public void conexion() {
		this.noSQL.conexion();
	}
	
	public String runQuery() {
		return this.noSQL.excecuteSentence();
	}
}

public class Main {

	public static void main(String[] args) {
		
		IConexionSQL conexion = new ConexionMySQL();
		// IConexionSQL conexion = new AdaptadorDB( new ConexionMongoDB() );
		
		conexion.conexion();
		
		String resultado = conexion.runQuery();
		System.out.println(resultado);

	}

}
</code></pre><p>En el ejemplo podemos ver dos clases <strong>IConexionNoSQL</strong> y <strong>IConexionSQL</strong> que no son compatibles entre si.
Mediante un adaptador podemos hacer que estas clases sean compatibles para el cliente(en este caso la clase <em>Main</em>), y de esta manera pasar de usar ConexionMysql a ConexionMongoDB, sin mayores cambios mas alla de una linea de codigo(donde se instancia a la clase reponsable de la conexion).</p><h3 id=composite>Composite<a class=anchor href=#composite>#</a></h3><p>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p><pre><code class=language-java>public interface IMenu {
	
	boolean open();
	
	boolean close();
	
	
}


import java.util.ArrayList;

public class Menu implements IMenu{
	
	private ArrayList&lt;IMenu&gt; menus;
	
	public Menu() {
		this.menus = new ArrayList&lt;IMenu&gt;();
	}
	
	public boolean open() {
		System.out.println(&quot;Open!&quot;);
		return true;
	}
	
	public boolean close() {
		System.out.println(&quot;Close!&quot;);
		return true;
	}
	
	public void addMenu(IMenu menu) {
		this.menus.add(menu);
	}
	
	public IMenu getMenu(int pos) {
		return this.menus.get(pos);
	}
	
}

public class Main {

	public static void main(String[] args) {
		Menu menu = new Menu();
		
		Menu menu2 = new Menu();
		Menu menu3 = new Menu();
		
		Menu menu4 = new Menu();
		Menu menu5 = new Menu();
		
		menu3.addMenu(menu4);
		menu3.addMenu(menu5);
		
		menu.addMenu(menu2);
		menu.addMenu(menu3);
		
		menu.open();
		menu.close();

	}

}

</code></pre><h3 id=decorador>Decorador<a class=anchor href=#decorador>#</a></h3><p>Attach additional responsibilities to on objects dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p><p>El patrón Decorator responde a la necesidad de añadir dinámicamente funcionalidad a un Objeto. Esto nos permite no tener que crear sucesivas clases que hereden de la primera incorporando la nueva funcionalidad, sino otras que la implementan y se asocian a la primera.</p><pre><code class=language-java>public interface IPizza {

	String descripcion();
	
	float precio();
}

public class PizzaHawaiana implements IPizza{
	
	public String descripcion() {
		return &quot;Pizza hawaiana&quot;;
	}
	
	public float precio() {
		return 8;
	}
	
}

public class PizzaPeperoni implements IPizza {
	
	public String descripcion() {
		return &quot;Pizza de peperoni&quot;;
	}
	
	public float precio() {
		return 8;
	}
}

public class OrillaRellena implements IPizza {

	private IPizza pizza;
	
	public OrillaRellena(IPizza pizza) {
		this.pizza = pizza;
	}
	
	public String descripcion() {
		return this.pizza.descripcion() + &quot; con orilla rellena&quot;;
	}
	
	public float precio() {
		return this.pizza.precio() + 4;
	}
	
}

public class QuesoExtra implements IPizza {

	private IPizza pizza;
	
	public QuesoExtra(IPizza pizza) {
		this.pizza = pizza;
	}
	
	public String descripcion() {
		return this.pizza.descripcion() + &quot; queso extra&quot;;
	}
	
	public float precio() {
		return this.pizza.precio() + 2;
	}
	
}

public class Main {
	
	public static void main(String[] args) {
		
		IPizza pizzaPeperoni = new QuesoExtra(new PizzaPeperoni());
		
		System.out.println(pizzaPeperoni.descripcion());
		System.out.println(pizzaPeperoni.precio());
		
		
		IPizza pizzaHawaiana = new QuesoExtra(new OrillaRellena(new PizzaHawaiana()));
		
		System.out.println(pizzaHawaiana.descripcion());
		System.out.println(pizzaHawaiana.precio());
		
	}

}
</code></pre><p>En el ejemplo pudimos extender nuestro catalogo de pizzas sin editar la herarquia o los tipos de pizza(Peperoni y Hawaiana) ya creadas.</p><p>Mediando los Decorators QuesoExtra y OrillaConQueso, pudimos extender las funcionabilidad del negocio. Si necesitaramos añadir mas caracteristicas, bastara con crear mas Decorartor que actuen como Wrapers.</p><h3 id=facade>Facade<a class=anchor href=#facade>#</a></h3><p>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p><p>Este patron es util. Para exponerle al cliente metodos sencillos con los cual el interactura. Ya que no es relevante para el la complegidad de alguna de nuestras operaciones. Ejemplo:</p><pre><code class=language-java>public class Fachada {

	private Computadora computadora;
	
	public Fachada() {
		
		ITeclado teclado = new Teclado();
		IMouse mouse = new Mouse();
		
		this.computadora = new Computadora(teclado, mouse);
	}
	
	public void encender() {
		//Complejas
		this.computadora.encender();
	}
	
}

public class Main {

	public static void main(String[] args) {
		
		Fachada fachaComputadora = new Fachada();
		
		fachaComputadora.encender();
	}

}
</code></pre><p>En el ejemplo vemos como para nuestro cliente(Main), es sencillo encender el computador por medio de una fachadad, donde dentro de esta se estan ejecutando tareas complejas como interactuar con tablas en a DB, conectarse a API, etc. Con la finalidad de llevar a cabo dicha tarea(encender el computador).</p><p>Pd: Para este Ejemplo se omitieron varias clases e interfaces porque distraerian al lector del patron principal.</p><h2 id=proxy>Proxy<a class=anchor href=#proxy>#</a></h2><p>Provide a surrogate or placeholder for another object to control access to it.</p><p>Este patron comunmente tiene como objectivo limitar funcinabilidades de nuestro sistema. Principalmente por temas de seguridad. Ejemplo:</p><pre><code class=language-java>public interface IServicio {
	
	void leer();
	
	void escribir();
	
	void actualizar();
	
	void eliminar();
	
}

public class Usuario {

	private int nivelPermiso;//1 -- 5 //5 == Admin

	public Usuario(int nivelPermiso) {
		this.nivelPermiso = nivelPermiso;
	}
	
	public int getNivelPermiso() {
		return nivelPermiso;
	}

	public void setNivelPermiso(int nivelPermiso) {
		this.nivelPermiso = nivelPermiso;
	}
	
	
	
}

public class Servicio implements IServicio{
	
	public void leer() {
		System.out.println(&quot;Leer!&quot;);
	}
	
	public void escribir() {
		System.out.println(&quot;Escribir!&quot;);
	}
	
	public void actualizar() {
		System.out.println(&quot;Actualizar!&quot;);
	}
	
	public void eliminar() {
		System.out.println(&quot;Eliminar!&quot;);
	}
	
}

public class ProxyServicio implements IServicio {

	private IServicio servicio;
	
	public ProxyServicio(Usuario usuario) {
		
	}
	
	public void leer() {
		this.obtenerServicio().leer();
	}
	
	public void escribir() {
		this.obtenerServicio().escribir();
	}
	
	public void actualizar() {
		this.obtenerServicio().actualizar();
	}
	
	public void eliminar() {
		this.obtenerServicio().eliminar();
	}
	
	private IServicio obtenerServicio() {
		if(this.servicio == null) {
			this.servicio = new Servicio();//
		}
		
		return this.servicio;
	}
}

public class Main {

	public static void main(String[] args) {
		
		Usuario usuario = new Usuario(5);
		IServicio servicio = new ProxyServicio(usuario);
		
		servicio.leer(); //&lt;--- Unica accion libre
		servicio.escribir();
		servicio.actualizar();
		servicio.eliminar();
		
	}

}
</code></pre><p>Nuestro Proxy le dara permisos de lectura a todo tipo de usuarios. Sin embargo, solo les dara permisos al resto de operacion a los usuarios Admin(aquellos con un nivel de rol igual a cinco).</p><p>Adicionalmente nuestro proxy solo esta creando el objecto <em>Servicio</em> en caso de que sea requerido(Esta estructura es conocidad como <strong>Virtual Proxy</strong>). Esto suponiendo que el dicho objeto tiene un alto costo de creación, por tal motivo no queremos crearlo innecesariamente.</p><h3 id=flyweight>Flyweight<a class=anchor href=#flyweight>#</a></h3><p>User sharing to support large number of fine-grained objects efficiently.</p><p>Este patron nos permite reutilizar objectos de tal manera que podamos crear aplicaciones con la minima cantidad de recursos necesarios(Aplicaciones ligeras).</p><pre><code class=language-java>public enum TipoNube {
	Chica,
	Mediana,
	Grande
}


import java.util.HashMap;

public class NubeFactory {

	private HashMap&lt;TipoNube, Nube&gt; nubesMap;
	
	public NubeFactory() {
		this.nubesMap = new HashMap&lt;TipoNube, Nube&gt;();
	}
	
	public Nube getNube(TipoNube tipo) {
		
		Nube nube = (Nube)this.nubesMap.get(tipo);
		
		if(nube == null) {
			nube = new Nube(tipo, &quot;nube.png&quot;, 100, 100);
			this.nubesMap.put(tipo, nube);
		}
		
		return nube;
	}
	
	public int countNubesMap() {
		return this.nubesMap.size();
	}
	
}


public class Nube {

	private TipoNube tipo;
	private String imagen;
	private int posX;
	private int posY;
	
	public Nube(TipoNube tipo, String imagen, int posX, int posY) {
		this.tipo = tipo;
		this.imagen = imagen;
		this.posX = posX;
		this.posY = posY;
	}

	public String getImagen() {
		return imagen;
	}

	public void setImagen(String imagen) {
		this.imagen = imagen;
	}

	public int getPosX() {
		return posX;
	}

	public void setPosX(int posX) {
		this.posX = posX;
	}

	public int getPosY() {
		return posY;
	}

	public void setPosY(int posY) {
		this.posY = posY;
	}

	public TipoNube getTipo() {
		return tipo;
	}

	public void setTipo(TipoNube tipo) {
		this.tipo = tipo;
	}
	
	
}

public class Main {

	public static void main(String[] args) {
	
		NubeFactory factory = new NubeFactory();
		
		for(int x = 0; x &lt; 100; x ++) {
			Nube nube = factory.getNube(TipoNube.Chica);
			System.out.println(nube);
		}
		
		for(int x = 0; x &lt; 200; x ++) {
			Nube nube = factory.getNube(TipoNube.Mediana);
			System.out.println(nube);
		}
		
		for(int x = 0; x &lt; 300; x ++) {
			Nube nube = factory.getNube(TipoNube.Grande);
			System.out.println(nube);
		}
		
		System.out.println(factory.countNubesMap());
	}

}

</code></pre><h2 id=de-comportamiento>De Comportamiento<a class=anchor href=#de-comportamiento>#</a></h2><h3 id=chain-of-responsibility>Chain of responsibility<a class=anchor href=#chain-of-responsibility>#</a></h3><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p><p>Example:</p><pre><code class=language-java>public enum TipoTransaccion {
	Deposito,
	Retiro,
	Reembolso,
	Cheques
}

public class Transaccion {
	
	private float cantidad;
	private float balance;
	private TipoTransaccion tipoTransaccion;
	
	public Transaccion(float cantidad, float balance, TipoTransaccion tipoTransaccion) {
		this.setCantidad(cantidad);
		this.setBalance(balance);
		this.setTipoTransaccion(tipoTransaccion);
	}

	public float getCantidad() {
		return cantidad;
	}

	public void setCantidad(float cantidad) {
		this.cantidad = cantidad;
	}

	public float getBalance() {
		return balance;
	}

	public void setBalance(float balance) {
		this.balance = balance;
	}

	public TipoTransaccion getTipoTransaccion() {
		return tipoTransaccion;
	}

	public void setTipoTransaccion(TipoTransaccion tipoTransaccion) {
		this.tipoTransaccion = tipoTransaccion;
	}
}

public interface IManejadorTransacciones {

	void setNextManejador(IManejadorTransacciones next);
	
	void ejecutarTransaccion(Transaccion transaccion);
	
}


public class Deposito implements IManejadorTransacciones {

	private IManejadorTransacciones next;
	
	public void setNextManejador(IManejadorTransacciones next) {
		this.next = next;
	}
	
	public void ejecutarTransaccion(Transaccion transaccion) {
		
		if(transaccion.getTipoTransaccion() == TipoTransaccion.Deposito) {
			float cantidad = transaccion.getCantidad() + transaccion.getBalance();
			System.out.println(&quot;El nuevo balances después de un deposito es : &quot; + cantidad);
		}else {
			this.next.ejecutarTransaccion(transaccion);
		}
		
	}
	
}

public class Reembolso implements IManejadorTransacciones {

	private IManejadorTransacciones next;
	
	public void setNextManejador(IManejadorTransacciones next) {
		this.next = next;
	}
	
	public void ejecutarTransaccion(Transaccion transaccion) {
		
		if(transaccion.getTipoTransaccion() == TipoTransaccion.Reembolso) {
			float cantidad = transaccion.getCantidad() + transaccion.getBalance();
			System.out.println(&quot;El nuevo balances después de un reembolso es : &quot; + cantidad);
		}else {
			System.out.println(&quot;Operación No Valida!&quot;);
		}
		
	}
}

public class Retiro implements IManejadorTransacciones {

	private IManejadorTransacciones next;
	
	public void setNextManejador(IManejadorTransacciones next) {
		this.next = next;
	}
	
	public void ejecutarTransaccion(Transaccion transaccion) {
		
		if(transaccion.getTipoTransaccion() == TipoTransaccion.Retiro) {
			float cantidad = transaccion.getCantidad() - transaccion.getBalance();
			System.out.println(&quot;El nuevo balances después de un retiro es : &quot; + cantidad);
		}else {
			this.next.ejecutarTransaccion(transaccion);
		}
		
	}
}

public class Main {

	public static void main(String[] args) {
		
		Transaccion transaccion = new Transaccion(100, 200, TipoTransaccion.Cheques);
		
		IManejadorTransacciones deposito = new Deposito();
		IManejadorTransacciones retiro = new Retiro();
		IManejadorTransacciones reembolso = new Reembolso();
		deposito.setNextManejador(retiro);
		retiro.setNextManejador(reembolso);
		
		deposito.ejecutarTransaccion(transaccion);
		
	}

}

</code></pre><p>El ejemplo anterior trata de un sistemas de transacciones bancarias. No es muy aplicable a la vida real pero sirve para mostrar este patron de deseño.</p><p>En el ejemplo vemos como la transaccion creada es pasada de objecto en objeto(Deposito, Retiro, Reembolso). Hasta dar con el objecto capaz de procesar dicha transaccion.</p><p>Para este ejemplo, el codigo podria tener un mejor performance. Principalmente si aplicaramos el Patron de diseño Virtual Proxy. Ya que si tuvieramos 100 objetos en la cadena. Es muy probable que instanciemos objetos(eslabones) que nunca utilizaremos.</p><h3 id=command>Command<a class=anchor href=#command>#</a></h3><p>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p><p>Es un patron de comportamiento. Se utiliza cuando hay una operacion, especialmente compleja, que debe ser realizada desde diferentes puntos de entrada.
Tipicamente este sucede cuando realizando una app WEB se debe realizar la misma operacion desde consulta de algun visitante como desde la linea de comandos.
Permite solicitar una operación a un objeto sin conocer realmente el contenido de esta operación, ni el receptor real de la misma. Para ello se encapsula la petición como un objeto, con lo que además facilita la parametrización de los métodos. Ejemplo:</p><pre><code class=language-java>public interface ICommand {

	void operacion();
	
}

public interface IDevise {
	
	void on();
	
	void off();
}

public class OffDevise implements ICommand {

	private IDevise devise;
	
	public OffDivise(IDevise devise) {
		this.devise = devise;
	}
	
	public void operacion() {
		this.devise.off();
	}
	
}

public class OnDevise implements ICommand {

	private IDevise devise;
	
	public OnDevise(IDevise devise) {
		this.devise = devise;
	}
	
	public void operacion() {
		this.devise.on();
	}
	
}

public class TV implements IDevise {
	
	private boolean on;
	
	public TV() {
		this.on = false;
	}
	
	public void on() {
		this.on = true;
		System.out.println(&quot;TV encendida!&quot;);
	}
	
	public void off() {
		this.on = true;
		System.out.println(&quot;TV apagada!&quot;);
	}
	
}

public class Main {

	public static void main(String[] args) {
		IDevise tv = new TV();
		
		ICommand on = new OnDevise(tv);
		ICommand off = new OffDevise(tv);
		
		on.operacion();
		off.operacion();
		
	}

}
</code></pre><p>En el ejemplo anterior podemos ver como los metodos &ldquo;on&rdquo; y &ldquo;off&rdquo;, quedaron completamente encapsulados desde una respectiva clase que implementa la interfaz ICommad. Como vimos en el ejemplo cada metodo debe poseer una clase por separado, es decir si tuvieramos 100 metodos, abrian 100 clases, una para cada metodo.</p><p>Usualmente la interfaz va de esta manera simple. ¿Que es lo que hara el &lsquo;operacion&rsquo; en este caso?
Bueno eso dependera del comando en especifico. pero de esta manera nos permite implementar facilmente el principio Open/Closed por ejemplo; Teniendo una lista de comando, ejecutarlos todos bajo un mismo metodo.</p><h3 id=iterator>Iterator<a class=anchor href=#iterator>#</a></h3><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p><p>Este patron provee un metodo estandar para acceder, secuencialmente a los elementos de una collección. En este Patron nosotros creamos una interfaz, de tal manera que si un objeto quiere acceder a los elementos de una collección, debera hacerlo por medio de la interfaz. De esta manera nosotros no exponemos los attributos ni metodos de la collección. Ejemplo</p><pre><code class=language-java>public interface Iterador {

	String siguiente();
	
	boolean contieneSiguiente();
	
}

import java.util.ArrayList;

public class GuiaTelefonica {

	private ArrayList&lt;String&gt; numeros;
	
	public GuiaTelefonica() {
		this.numeros = new ArrayList&lt;String&gt;();
	}
	
	public void add(String numero) {
		this.numeros.add(numero);
	}
	
	public ArrayList&lt;String&gt; getNumeros() {
		return this.numeros;
	}
	
}

public class IteradorGuia implements Iterador {

	private GuiaTelefonica guia;
	private int posicion;
	
	public IteradorGuia(GuiaTelefonica guia) {
		this.guia = guia;
	}
	
	public String siguiente() {
		return this.guia.getNumeros().get(this.posicion++);
	}
	
	public boolean contieneSiguiente() {
		return this.posicion &lt; this.guia.getNumeros().size()
				&amp;&amp; this.guia.getNumeros().get(this.posicion) != null;
	}
	
}

public class Main {

	public static void main(String[] args) {
		GuiaTelefonica guia = new GuiaTelefonica();
		
		guia.add(&quot;123&quot;);
		guia.add(&quot;124&quot;);
		guia.add(&quot;125&quot;);
		guia.add(&quot;126&quot;);
		guia.add(&quot;127&quot;);
		guia.add(&quot;128&quot;);
		
		Iterador iterador = new IteradorGuia(guia);
		
		while(iterador.contieneSiguiente()) {
			System.out.println(iterador.siguiente());
		}

	}

}
</code></pre><h3 id=mediator>Mediator<a class=anchor href=#mediator>#</a></h3><p>Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</p><p>Ese patron lo usaremos cuando deseemos comunicar objectos. Una analogia podria ser la de una torre de control(El mediador). Ya que esta enconstante comunicacion con las areonaves, y permite que las areonaves puedan comunicarse entre ellas.</p><p>A diferencia de otros patros, en este no tenemos un conjunto de reglas a seguir. Nos tendremos que valer en gran parte de nuestra intuición como desarrolladores.</p><p>En el seguiente ejemplo veremos un pequeño sistema de chat.</p><pre><code class=language-java>public class Usuario {
	
	private String nombre;
	
	public Usuario(String nombre) {
		this.nombre = nombre;
	}
	
	public void recibirMensaje(String mensaje) {
		System.out.println(mensaje);
	}
	
	public String getNombre() {
		return this.nombre;
	}

}

import java.util.HashMap;

public class SalaChat {

	private HashMap&lt;String, Usuario&gt; usuarios;
	
	public SalaChat() {
		this.usuarios = new HashMap&lt;String, Usuario&gt;();
	}
	
	public void addParticipante(Usuario usuario) {
		this.usuarios.put(usuario.getNombre(), usuario);
	}
	
	public void enviarMensaje(Usuario remitente, Usuario receptor, String mensaje) {
		
		if(this.usuarios.get(remitente.getNombre()) != null &amp;&amp;
				this.usuarios.get(receptor.getNombre()) != null) {
			
			mensaje = &quot;De :&quot; + remitente.getNombre() + &quot; mensaje :&quot; + mensaje;
			receptor.recibirMensaje(mensaje);
			
		}
	}
}

public class Main {

	public static void main(String[] args) {
		
		Usuario eduardo = new Usuario(&quot;Eduardo&quot;);
		Usuario codi = new Usuario(&quot;Codi&quot;);
		
		SalaChat sala = new SalaChat();
		
		sala.addParticipante(eduardo);
		sala.addParticipante(codi);
		
		sala.enviarMensaje(eduardo, codi, &quot;Hola desde el curso de patrones de diseño!&quot;);

	}
}
</code></pre><h3 id=memento>Memento<a class=anchor href=#memento>#</a></h3><p>Without violating encapsulation, capture and externalize an object&rsquo;s internal state so that the object can be restored to this state later.</p><p>Permite capturar y exportar el estado interno de un objeto, para que luego se pueda restaurar sin romper la enapsulación.
Con memento nosotros podremos crear una copia de seguridad de un objeto, y si necesitamos revertir los cambio, podremos hacerlos desde dicha copia. Es decir podremos hacer un &ldquo;Control Z&rdquo;.</p><p>La copia de seguridad puede ser parcial o total.</p><p>Para implementar este patron unicamente necesitaremos dos clases. Veamoslo en el siguiente ejemplo:</p><pre><code class=language-java>
public class Usuario {

	private String nombre;
	private int edad;
	
	public Usuario(String nombre, int edad) {
		this.setNombre(nombre);
		this.setEdad(edad);
	}
	
	public Usuario getMemento() {
		return new Usuario(this.getNombre(), this.getEdad());
	}
	
	public void restartMemento(Usuario usuario) {
		this.setNombre(usuario.getNombre());
		this.setEdad(usuario.getEdad());
	}
	
	public String getNombre() {
		return nombre;
	}

	public void setNombre(String nombre) {
		this.nombre = nombre;
	}

	public int getEdad() {
		return edad;
	}

	public void setEdad(int edad) {
		this.edad = edad;
	}
	
}

public class Main {

	public static void main(String[] args) {
		
		Usuario usuario = new Usuario(&quot;Codi&quot;, 6 );
		
		Usuario memento = usuario.getMemento();//Nuestra copia!
		
		usuario.setNombre(&quot;Cambio de nombre&quot;);
		usuario.setEdad(20);
		
		System.out.println(usuario.getNombre());
		System.out.println(usuario.getEdad());
		
		usuario.restartMemento(memento);
		
		System.out.println(usuario.getNombre());
		System.out.println(usuario.getEdad());
		
	}

}

</code></pre><h3 id=observer>Observer<a class=anchor href=#observer>#</a></h3><p>Define at one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p><p>El patrón observer se compone de un sujeto que ofrece mecanismos de suscripción y desuscripción a múltiples observadores que quieren ser notificados de los cambios en dicho sujeto.</p><p>Es uno de los patrones más utilizados, algunos ejemplos típicos son:
Newsletter
Sockets
Listeners en páginas web</p><p>Crearemos una interfaz, y esta la vamos a implementar en los observadores, es decir en los objetos que esta interesado en el cambio. Dentro de esta interfaz nosotros colocaremos las direfentes acciones que un observador puede tener(Resurtir bodega, generar factura, etc).</p><p>Tendremos otra Interfaz <em>Observable</em>, esta debe posser al menos dos metodos; <strong>addObserver</strong> y <strong>notify</strong>.</p><p>Ejemplo:</p><pre><code class=language-java>
public interface IObservable {

	void addObserver(IObserver o);
	
	void notificarObservadores();
	
	void removeObserver();
	
}

public interface IObserver {

	void notificacion(String mensaje);
	
}

import java.util.Set;
import java.util.LinkedHashSet;

public class Producto implements IObservable {
	
	private Set&lt;IObserver&gt; observadores;
	
	private int stock;
	
	public Producto(int stock) {
		this.stock = stock;
		this.observadores = new LinkedHashSet&lt;&gt;();
	}
	
	public void venta() {
		this.setStock(this.stock - 1);
		System.out.println(&quot;Producto vendido!&quot;);
		
		this.notificarObservadores();
	}

	public int getStock() {
		return stock;
	}

	public void setStock(int stock) {
		this.stock = stock;
	}
	
	public void addObserver(IObserver o) {
		this.observadores.add(o);
	}
	
	public void notificarObservadores() {
		for(IObserver observador : this.observadores)
			observador.notificacion(&quot;EL producto se vendio!&quot;);
	}
	
	public void removeObserver() {
		
	}
}

public class Usuario implements IObserver {

	public void notificacion(String mensaje){
		System.out.println(mensaje);
	}
	
}

public class Main {

	public static void main(String[] args) {
		
		Producto aguacate = new Producto(10);
		
		Usuario usuario1 = new Usuario();
		Usuario usuario2 = new Usuario();
		Usuario usuario3 = new Usuario(); //
		
		aguacate.addObserver(usuario1);
		aguacate.addObserver(usuario2);
		
		aguacate.venta();
	}
}
</code></pre><h3 id=state>State<a class=anchor href=#state>#</a></h3><p>Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p><p>Este patron lo utilizaremos cuando trabajemos con maquinas de estado</p><p>Utilizando el patron State, nosotros debemos crear una interfaz con todos nuestros estados y una nueva clase por cada estado de nuestro objeto.</p><p>Ejemplo:</p><pre><code class=language-java>public interface IEstadoAuto {

	void encender();
	
	void manejar();
	
	void apagar();
	
}

public class AutoApagar implements IEstadoAuto {
	
	private final Auto auto;
	
	public AutoApagar(Auto auto) {
		this.auto = auto;
	}
	
	public void encender() {
		System.out.println(&quot;El auto esta encendido!&quot;);
		auto.setEstadoActual(auto.getAutoEncendio());
	}
	
	public void manejar() {
		System.out.println(&quot;El auto no se puede manejar si esta apagado!&quot;);
	}
	
	public void apagar() {
		System.out.println(&quot;El auto ya esta apagado!&quot;);
	}
	
}

public class AutoEncender implements IEstadoAuto {
	
	private final Auto auto;
	
	public AutoEncender(Auto auto) {
		this.auto = auto;
	}
	
	public void encender() {
		System.out.println(&quot;El auto esta encendido!&quot;);
	}
	
	public void manejar() {
		System.out.println(&quot;El auto esta en movimiento!&quot;);
		auto.setEstadoActual(auto.getAutoMovimiento());
	}
	
	public void apagar() {
		System.out.println(&quot;El auto esta apagado!&quot;);
		auto.setEstadoActual(auto.getAutoApagado());
	}
	
}

public class AutoManejar implements IEstadoAuto {
	
	private final Auto auto;
	
	public AutoManejar(Auto auto) {
		this.auto = auto;
	}
	
	public void encender() {
		System.out.println(&quot;El auto ya esta encendido!&quot;);
	}
	
	public void manejar() {
		System.out.println(&quot;El auto ya se esta moviendo!&quot;);
	}
	
	public void apagar() {
		System.out.println(&quot;El auto esta apagado!&quot;);
		auto.setEstadoActual(auto.getAutoApagado());
	}
	
}

public class Auto implements IEstadoAuto {
  
  private IEstadoAuto autoEncendio;
  private IEstadoAuto autoMovimiento;
  private IEstadoAuto autoApagado;
  
  IEstadoAuto estadoActual;
  
  public Auto() {
    this.autoEncendio = new AutoEncender(this);
    this.autoApagado = new AutoApagar(this);
    this.autoMovimiento = new AutoManejar(this);
    
    this.estadoActual = this.autoApagado;
  }
  
  public void encender() {
    this.estadoActual.encender();
  }
  
  public void manejar() {
    this.estadoActual.manejar();
  }
  
  public void apagar() {
    this.estadoActual.apagar();
  }

  public IEstadoAuto getAutoEncendio() {
    return autoEncendio;
  }

  public void setAutoEncendio(IEstadoAuto autoEncendio) {
    this.autoEncendio = autoEncendio;
  }

  public IEstadoAuto getAutoMovimiento() {
    return autoMovimiento;
  }

  public void setAutoMovimiento(IEstadoAuto autoMovimiento) {
    this.autoMovimiento = autoMovimiento;
  }

  public IEstadoAuto getAutoApagado() {
    return autoApagado;
  }

  public void setAutoApagado(IEstadoAuto autoApagado) {
    this.autoApagado = autoApagado;
  }

  public IEstadoAuto getEstadoActual() {
    return estadoActual;
  }

  public void setEstadoActual(IEstadoAuto estadoActual) {
    this.estadoActual = estadoActual;
  }
  
}

public class Main {

	public static void main(String[] args) {
		Auto auto = new Auto();
	    
		auto.apagar();
		auto.encender();
		auto.manejar();
		
	    /*
	     * Encendido
	     * En Movimiento
	     * Apagado
	     * */
	}

}
</code></pre><h3 id=strategy>Strategy<a class=anchor href=#strategy>#</a></h3><p>Define a family of algorithms, encapsulate each one, and make then interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p><p>Nos permite encapsular algoritmos en clases, de tal manera que nosotros podamos utilizar diferentes algoritmos en tiempo de ejecución, podemos verlo como una caja de lego, donde cada pieza es un algoritmo y dependiendo de nuestras necesidades en tiempo de ejecución nosotros podremos utiizar una pieza u otra.</p><p>Este patron es muy usado cuando nuestra aplicación tiene muchas varientes en los algoritmos. Como por ejemplo un sistema de comisiones.</p><p>Veamos un ejemplo con dos tipo de algoritmos(dos clases), deposito y retiro:</p><ol><li>Se crea la interfaz base.</li><li>Se crean las clases por algoritmo.</li><li>Se crea una clase contexto.</li></ol><pre><code class=language-java>public interface IEstrategia {

	float realizarOperacion(float balance, float cantidad);
	
}

public class Retiro implements IEstrategia {

	public float realizarOperacion(float balance, float cantidad) {
		return balance - cantidad;
	}
	
}

public class Deposito implements IEstrategia {

	public float realizarOperacion(float balance, float cantidad) {
		return balance + cantidad;
	}
	
}

public class Transaccion {

	private IEstrategia estrategia;//algoritmo
	
	public Transaccion(IEstrategia estrategia) {
		this.estrategia = estrategia;
	}
	
	public float ejecutarTransaccion(float balance, float cantidad) {
		return this.estrategia.realizarOperacion(balance, cantidad);
	}
	
	
}

public class Main {

	public static void main(String[] args) {

		Transaccion transaccion1 = new Transaccion( new Deposito() );
		System.out.println(transaccion1.ejecutarTransaccion(100, 20));
		
		
		Transaccion transaccion2 = new Transaccion( new Retiro() );
		System.out.println(transaccion2.ejecutarTransaccion(100, 20));
		
	}

}
</code></pre><h3 id=template-method>Template Method<a class=anchor href=#template-method>#</a></h3><p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm&rsquo;s structure.</p><pre><code class=language-java>public abstract class Usuario {

	public void autenticacion() {
		System.out.println(&quot;TODOS los usuarios necesitan autenticarse!&quot;);
	}
	
	abstract void formaTrabajar();
	
}

public class Administrador extends Usuario {

	public void formaTrabajar() {
		System.out.println(&quot;La forma de trabajar de un Administrador!&quot;);
	}
	
}

public class Gerente extends Usuario {

	public void formaTrabajar() {
		System.out.println(&quot;La forma de trabajar de un Gerente!&quot;);
	}
	
}

public class Main {

	public static void main(String[] args) {
		
		Usuario gerente = new Gerente();
		Usuario administrador = new Administrador();
		
		gerente.autenticacion();
		gerente.formaTrabajar();
		
		administrador.autenticacion();
		administrador.formaTrabajar();

	}

}
</code></pre><p>Este patron basicamente trata en abstraer los metodos en comun de los objetos relacionados.</p><p>En este caso el tipo de usuario Admin y Manager, heredan de la clase abstracta User, que viene siendo el Template.</p><h3 id=visitor>Visitor<a class=anchor href=#visitor>#</a></h3><p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p><p>Si un objeto es el responsable de mantener cierto tipo de información, entonces, es logico asignarle tambien todas las operaciones que manipulen esa información.</p><p>Para esto generaremos dos interfaces:</p><ul><li>una Visitor: Sera la encargada de gestionar los distintos tipo de algoritmos, esta interfaz tendra una sobre carga de metodos usualmente.</li><li>una Visitable: Sera la encargada de llamar a algoritmo perse.</li></ul><pre><code class=language-java>public interface IFruta {

	float getPrecio();

}

public interface ILineaBlanca {

	float getPrecio();
	
}

public interface IVisitor {

	float descuento(IFruta fruta);//descuento
	
	float descuento(ILineaBlanca lineaBlanca);
	
}

public interface IVisitable {

	float aplicarDescuento(IVisitor visitor);
	
}

public class Lavadora implements IFruta, IVisitable {

	public float getPrecio() {
		return 20f;
	}
	
	public float aplicarDescuento(IVisitor visitor) {
		return visitor.descuento(this);
	}
	
}

public class Manzana implements IFruta, IVisitable {

	public float getPrecio() {
		return 2f;
	}
	
	public float aplicarDescuento(IVisitor visitor) {
		return visitor.descuento(this);
	}
	
}

public class Main {
	
	public static void main(String[] args) {
		
		//Fruta 10% de descuento
		//LíneBlanca 5% de descuento
		
		
		Manzana manzana = new Manzana();
		Lavadora lavadora = new Lavadora();
		
		IVisitor descuento = new DescuentoComun();
		
		System.out.println(manzana.aplicarDescuento(  descuento ));
		System.out.println(lavadora.aplicarDescuento(  descuento));
		
	}
}
</code></pre><h1 id=documentacion>Documentacion</h1><p>Documentar es una de las mejores prácticas que podemos hacer cuando estamos en un equipo de trabajo.</p><ul><li>Dejar por escrito cómo hemos hecho algunas funcionalidades.¿Cual es la logica del negocio?</li><li>Sobretodo debemos dejar comentarios en el código que ayuden a las personas a ubicarse en qué parte de la aplicación están y qué hacen esas líneas de código.</li></ul><h2 id=que-documentar>¿Que Documentar?<a class=anchor href=#que-documentar>#</a></h2><p>Es un poco complejo pero basicamente tienes que documentar pensando en la persona que tomara tu codigo cuando tu lo deje(esa persona que continuara tu trabajo), tienes que documentar pensando en que la persona que leera esas linea no tiene la menor idea de que hace tu aplicacion. Algunas preguntas utilies para documentar tu codigo son:</p><ul><li>¿Como implementar una nueva funcionalidad en caso de querer hacerlo?</li><li>¿Cómo podría ser mejorando el código?.</li><li>¿Como se realizan las pruebas?</li><li>¿Quienes son los involucrados en el proyecto?</li><li>¿Como se puede llevar nuevo codigo a produccion?</li><li>Etc. Toda aquella pregunta que nos lleve a ser mas claros en como manipular el codigo.</li></ul><h2 id=como-documentar>¿Como Documentar?<a class=anchor href=#como-documentar>#</a></h2><p>Esta depende de quienes son las personas que leeran este codigo.</p><ul><li>¿Usan lenguaje tecnico?</li><li>¿tiene suficiente experiencia?</li><li>¿Tiene un conocimiento similar al tuyo?</li></ul><p>Al hablar de Documentacion no hablamos solamente de texto, los graficos tambien son muy buenos para comprender las ideas como por ejemplo UML.</p><h2 id=donde-documentar>¿Donde documentar?<a class=anchor href=#donde-documentar>#</a></h2><p>Basicamente existen dos lugar:</p><ul><li><strong>Dentro del propio codigo.</strong></li></ul><pre><code class=language-php>&lt;?php

/** 

* Retorna la suma de dos numeros enteros
* @param int $a
* @param int $b

*/
function add ( int $a, int $b ) {
   
    return $a +$b;
}
</code></pre><p>Documentacion clara, concisa y pequeña.</p><ul><li><strong>Algun otro repositorio:</strong> una wiki, documentos compartidos, etc.</li></ul><h2 id=cuando-documentar>¿Cuando documentar?<a class=anchor href=#cuando-documentar>#</a></h2><ul><li><p>Lo ideal es ir escribiendo la documentacion a la par del codigo. A penas terminas de escribir el codigo, ir y escribir su documentacion.</p></li><li><p>Cuando pudiste resolver un problema bastate complejo y notaste que te faltaba informacion.</p></li></ul><h1 id=testing-automatizado>Testing Automatizado</h1><p>Existen dos tipos de testing, es completamente recomendado(es lo correcto) realizar ambos tipos:</p><p><em>NOTA:</em> En <em>PHP</em> podemos utilizar <em>phpUnit</em> para realizar nuestros test.</p><ol><li><strong>Unit Testing:</strong></li></ol><p>Evaluamos el funcionamiento de los componentes individualmente. Esto fomenta:</p><ul><li>el refactory(volver a escribir el codigo de una mejor manera).</li><li>Facilita la integracion con otras piezas de codigo.</li><li>Ayuda a dejar el codigo documentado.</li></ul><p>Para <strong>implementar el unit testing</strong> requerimos de una herramienta que nos permita escribir el test y por otro lado mirar sus resultados.</p><ol start=2><li><strong>Integration Testing</strong>: Validar la interacción entre los componentes y el sistema completo. En estas pruebas se evalua y hacen prueba ya del &lsquo;producto&rsquo; final que debe arrojar el programa.</li></ol><h2 id=creacion-de-un-entorno-de-pruebas-en-php>Creacion de un entorno de pruebas en PHP<a class=anchor href=#creacion-de-un-entorno-de-pruebas-en-php>#</a></h2><p>crearemos un entorno para poder ejecutar PHPUnit (El framework de pruebas unitarias más utilizado con PHP).</p><ol><li><strong>Descargar el proyecto</strong></li></ol><p>El primer paso es clonar el repositorio <a href=https://github.com/mchojrin/platzi-tdd>https://github.com/mchojrin/platzi-tdd</a></p><ol start=2><li><strong>Instalar PHP</strong></li></ol><p>Si estás en un entorno Linux o Mac probablemente ya tendrás PHP instalado, con lo cual puedes saltar este paso.</p><p>Si estás en Windows deberás descargar PHP de aquí y probablemente también tengas que instalar el Runtime de Visual C++ que puedes descargar de aquí.</p><p>Para comprobar que la instalación haya sido exitosa debes abrir una terminal y ejecutar el comando php -v.</p><ol start=3><li><strong>Instalar Composer</strong></li></ol><p>Una vez instalado PHP el siguiente paso es instalar composer, un manejador de dependencias para php (Puedes leer más de qué se trata <a href=https://academy.leewayweb.com/que-es-composer/>aquí</a>).</p><p>La forma más simple de instalar composer es hacerlo a través del propio php siguiendo las instrucciones presentes <a href=https://getcomposer.org/download/>aquí</a>.</p><p>Si utilizas Windows puedes usar <a href=https://getcomposer.org/Composer-Setup.exe>este</a> instalador.</p><ol start=4><li><strong>Instalar PHPUnit</strong></li></ol><p>PHPUnit es una librería estándar para la ejecución de pruebas unitarias de PHP.</p><p>En general puedes descargarlo de <a href=https://phpunit.de/getting-started/phpunit-8.html>aquí</a>. En este caso, utilizaremos la versión de instalación por proyecto.</p><p>PHPUnit es la dependencia principal de nuestro proyecto, si tienes instalado composer, su instalación es muy simple.</p><p>Sólo debes abrir una terminal en el directorio donde descargaste el proyecto y ejecutar <code>composer install</code> .</p><p>El resultado debería verse similar a:</p><p><img src=img/good-practices/phpUnit.jpg alt=phpUnit1></p><p>Para verificar la instalación ejecuta el comando <code>php vendor/phpunit/phpunit/phpunit</code></p><p>La salida debería verse así:</p><p><img src=img/good-practices/phpUnit2.jpg alt=phpUnit2></p><ol start=5><li><strong>Configurar el entorno</strong></li></ol><p>Durante este curso utilizamos Visual Studio Code. Si ya dispones de otro entorno y lo conoces bien puedes utilizarlo, si no tienes preferencia te recomiendo que utilices VS Code.</p><p>Puedes descargarlo de <a href=https://code.visualstudio.com/Download>aquí</a></p><p>Una vez instalado abre la carpeta donde descargaste el proyecto en Visual Studio. Deberas ver algo como:</p><p><img src=img/good-practices/code.jpg alt=code></p><p>Escribe un primer test para verificar que todo está configurado correctamente:</p><p><img src=img/good-practices/test1.jpg alt=test1></p><p>Y para ejecutarlo, abre un terminal dentro del Visual Studio Code:</p><p><img src=img/good-practices/cmd.jpg alt=cmd></p><p>Una vez en la consola escribe el comando: <code>php vendor/phpunit/phpunit/phpunit tests</code></p><p><img src=img/good-practices/test2.jpg alt=test2></p><p>Y deberás ver en la salida:</p><p><img src=img/good-practices/test3.jpg alt=test3></p><p>Con esto tendrás todo lo necesario para avanzar al proximo punto(TDD)</p><h2 id=test-driven-development>Test Driven Development<a class=anchor href=#test-driven-development>#</a></h2><p><a href="https://www.youtube.com/watch?time_continue=44&v=EBtu4WyWHPc">TDD</a> o Test Driven Development es una metodología donde hacemos todo al revés(Esta propone: Primero escribir las pruebsa y luego el software). Por un momento vamos a dejar de programar para dedicarnos a escribir las pruebas.</p><p>Este tipo de prueba es del tipo <em>unit test</em> y Se trata de lo siguiente:</p><ul><li>Pensar en una funcionalidad que queremos implementar y preguntarnos ¿Como vamos a determinar que lo que vayamos a implementar efectivamente es correcto y hace lo que debe hacer?</li><li>Escribimos el test</li><li>Esperamos que falle.</li><li>Escribimos el minimo codigo necesario para que funcione.</li><li>Examinamos nuestro codigo en busca de mejoras.</li><li>Repetir</li></ul><p>Ejemplo:</p><pre><code class=language-php>&lt;?php 

use PHPUnit\Framework\TestCase;

class CalculatorTest extends TestCase
{
    public function testAddWillReturnTheSumOfItsParameters()
    {
        $sut = new Calculator();
     
        $this-&gt;assertEquals(8, $sut-&gt;add(5,3));
        $this-&gt;assertEquals(5, $sut-&gt;add(5,0));
    }

    public function testAddWillReturnTheSubtractOfItsParameters()
    {
        $sut = new Calculator();
     
        $this-&gt;assertEquals(5, $sut-&gt;subtract(8,3));
        $this-&gt;assertEquals(8, $sut-&gt;subtract(10,2));
        $this-&gt;assertEquals(2, $sut-&gt;subtract(4,2));
    }
    
    public function testAddWillReturnTheMultiplyOfItsParameters()
    {
        $sut = new Calculator();
     
        $this-&gt;assertEquals(24, $sut-&gt;multiply(8,3));
        $this-&gt;assertEquals(20, $sut-&gt;multiply(10,2));
        $this-&gt;assertEquals(8, $sut-&gt;multiply(4,2));
    }

    public function testAddWillReturnTheDivideOfItsParameters()
    {
        $sut = new Calculator();
     
        $this-&gt;assertEquals(5, $sut-&gt;divide(10,2));
        $this-&gt;assertEquals(20, $sut-&gt;divide(40,2));
        $this-&gt;assertEquals(4, $sut-&gt;divide(8,2));
    }
}

&lt;?php
class Calculator
{
    public function add(int $a, int $b): int
    {
        return $a + $b;
    }
    
    public function subtract(int $a, int $b): int
    {
        return $a - $b;
    }
    
    public function multiply(int $a, int $b): int
    {
        return $a * $b;
    }

    public function divide(int $a, int $b): float
    {
        if ($b ===0) {
            thrownew InvalidArgumentException('No se puede dividir entre 0');
        }
        return $a / $b;
    }
    
}

Resultados de pruebas:

root@debian:/var/www/html/platzi/platzi-tdd# vendor/phpunit/phpunit/phpunit --testdox  tests/CalculatorTest.php
PHPUnit 8.2.2 by Sebastian Bergmann and contributors.

Calculator
 ✔ Add will return the sum of its parameters
 ✔ Add will return the subtract of its parameters
 ✔ Add will return the multiply of its parameters
 ✔ Add will return the divide of its parameters

Time: 52 ms, Memory: 4.00 MB

OK (4 tests, 11 assertions)
</code></pre></article><div class=pagination><a class=pagination__item href=https:///jmillandev.github.io/apuntes/javascript/><span class=pagination__label>Previous Post</span>
<span class=pagination__title></span></a><a class=pagination__item href=https:///jmillandev.github.io/apuntes/golang/><span class=pagination__label>Next Post</span>
<span class=pagination__title></a></a></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"jmillandev"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=post__footer><div class=social-icons><a class=social-icons__link title=Twitter href=https://twitter.com/jmillandev target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/twitter.svg)></div></a><a class=social-icons__link title=GitHub href=https://github.com/jmillandev target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/github.svg)></div></a><a class=social-icons__link title=LinkedIn href=https://www.linkedin.com/in/jmillandev-42664412a/ target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/linkedin.svg)></div></a></div><p>© 2022</p></footer></div></div></div></main><script src=/jmillandev.github.io/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr+kQ=" crossorigin=anonymous></script><script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script><script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script></body></html>