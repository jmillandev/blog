<!doctype html><html lang=es-es><head><title>| Jesús Millán</title><meta charset=utf-8><meta name=language content="en"><meta name=description content><meta name=keywords content><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content><meta name=twitter:site content="@jmillandev"><meta name=twitter:creator content="https://twitter.com/jmillandev"><link rel="shortcut icon" type=image/png href=/favicon.ico><link type=text/css rel=stylesheet href=/jmillandev.github.io/css/post.min.2cb93c91050d1853bf971cc31e00122edd6e0f405aa1de3b7f8ef67ea3b5a79a.css integrity="sha256-LLk8kQUNGFO/lxzDHgASLt1uD0Baod47f472fqO1p5o="><link type=text/css rel=stylesheet href=/jmillandev.github.io/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/\/jmillandev.github.io\/apuntes\/oop\/","name":"","author":{"@type":"Person","name":""},"description":""}</script></head><body><div class=burger__container><div class=burger aria-controls=navigation aria-label=Menu><div class="burger__meat burger__meat--1"></div><div class="burger__meat burger__meat--2"></div><div class="burger__meat burger__meat--3"></div></div></div><nav class=nav id=navigation><ul class=nav__list><li><a href=/jmillandev.github.io/>About</a></li><li><a class=active href=/jmillandev.github.io/apuntes/>Apuntes</a></li><li><a href=/jmillandev.github.io/blog/>Blog</a></li></ul></nav><main><style>@media(min-width:1024px){.post{width:85%;margin:0 auto;max-width:100%}}</style><div class=flex-wrapper><div class=post__container><div class=post><header class=post__header><h1 id=post__title></h1></header><article class=post__content><h1 id=paradigma-orientado-a-objetos>Paradigma Orientado a Objetos</h1><p>La <strong>Programación Orientada a Ojetos</strong> viene de una filosofía o forma de pensar que es la Orientación a Objetos y esto surge a partir de los problemas que necesitamos plasmar en código.</p><p>Es analizar un problema en forma de objetos para después llevarlo a código, eso es la <strong>Orientación a Objetos</strong>.</p><p>Un paradigma es una teoría que suministra la base y modelo para resolver problemas. La paradigma de Programación Orientada a Objetos se compone de 4 elementos:</p><ul><li>Clases</li><li>Propiedades</li><li>Métodos</li><li>Objetos</li></ul><p>Y 4 Pilares:</p><ul><li>Encapsulamiento</li><li>Abstracción</li><li>Herencia</li><li>Polimorfismo</li></ul><p>En POO se implementa mucho <strong>Don’t repeat yourself</strong> es una filosofía que promueve la reducción de duplicación en programación, esto nos va a inculcar que no tengamos líneas de código duplicadas.</p><p>Toda pieza de información nunca debería ser duplicada debido a que incrementa la dificultad en los cambios y evolución</p><h1 id=lenguajes-orientados-a-objetyos>Lenguajes orientados a objetyos</h1><p>Algunos de los lenguajes de programación Orientados a Objetos son:</p><ol><li>Java:</li></ol><ul><li>Orientado a Objetos naturalmente</li><li>Es muy útilizado en Android</li><li>Y es usado del lado del servidor o Server Side</li></ul><ol start=2><li>PHP:</li></ol><ul><li>Lenguaje interpretado</li><li>Pensado para la Web</li></ul><ol start=3><li>Python:</li></ol><ul><li>Diseñado para ser fácil de usar</li><li>Múltiples usos: Web, Server Side, Análisis de Datos, Machine Learning, etc</li></ul><ol start=4><li>Javascript:</li></ol><ul><li><p>Lenguaje interpretado</p></li><li><p>Orientado a Objetos pero basado en <em>prototipos</em></p></li><li><p>Pensado para la Web</p></li><li><p>C#</p></li><li><p>Ruby</p></li><li><p>Kotlin</p></li></ul><h1 id=pasos-para-la-resolucion-de-un-problema-en-poo>Pasos para la resolucion de un problema en POO</h1><ol><li>Analizar el problema</li></ol><ul><li>Observacion.</li><li>Entendimiento.</li><li>Lectura.</li></ul><ol start=2><li>Plasmar (Analisi del problema)</li></ol><ul><li>Diagramas</li></ul><ol start=3><li>Programar (Diagramas)</li></ol><h1 id=diagramas-de-modelado>Diagramas de modelado</h1><h2 id=omt>OMT<a class=anchor href=#omt>#</a></h2><p>Object Modeling Techniques. Es una metodología para el análisis orientado a objetos. <strong>DESCONTINUADO</strong></p><h2 id=uml>UML<a class=anchor href=#uml>#</a></h2><p>Unified Modeling Language o Lenguaje de Modelado Unificado. Tomó las bases y técnicas de OMT unificándolas. Tenemos más opciones de diagramas como lo son:</p><ul><li>Clases.</li><li>Casos de Uso.</li><li>Objetos.</li><li>Actividades.</li><li>Iteración.</li><li>Estados.</li><li>Implementación.</li></ul><p>Esto significa que tendremos una manejara gráfica de representar una situación, justo como hemos venido viendo. A continuación se presentan los elementos que podemos utilizar para hacer estas representaciones.</p><p>Las <strong>clases</strong> se representan así:</p><p><img src=img/OOP/UML-clase.jpg alt="Clases en UML"></p><p>En la parte superior se colocan los atributos o propiedades, y debajo las operciones de la clase. Notarás que el primer caractér con el que empiezan es un símbolo. Este denotará la visibilidad del atributo o método, esto es un termino que tiene que ver con Encapsulamiento.</p><p>Estos son los niveles de visibilidad que puedes tener:</p><p><strong>-</strong> private.
<strong>+</strong> public.
<strong>#</strong> protected.
<strong>~</strong> default.</p><p>Una forma de representar las relaciones que tendrá un elemento con otro es a través de las flechas en UML, y aquí tenemos varios tipos, estos son los más comúnies:</p><h3 id=asociación>Asociación<a class=anchor href=#asociación>#</a></h3><p><img src=img/OOP/UML-asociacion.jpg alt="Clases en UML"></p><p>Como su nombre lo dice, notarás que cada vez que esté referenciada este tipo de flecha significará que ese elemento contiene al otro en su definición. La flecha apuntará hacia la dependencia.</p><p><img src=img/OOP/UML-asociacion2.jpg alt="Clases en UML"></p><p>Con esto vemos que la ClaseA está asociada y depende de la ClaseB.</p><h3 id=herencia>Herencia<a class=anchor href=#herencia>#</a></h3><p><img src=img/OOP/UML-herencia.jpg alt="Clases en UML"></p><p>Siempre que veamos este tipo de fecha se estará expresando la herencia.
La dirección de la flecha irá desde el <strong>hijo hasta el padre</strong>.</p><p><img src=img/OOP/UML-herencia2.jpg alt="Clases en UML"></p><p>Con esto vemos que la ClaseB hereda de la ClaseA</p><h3 id=agregación>Agregación<a class=anchor href=#agregación>#</a></h3><p><img src=img/OOP/UML-agregacion.jpg alt="Clases en UML"></p><p>Este se parece a la asociación en que un elemento dependerá del otro, pero en este caso será: Un elemento dependerá de muchos otros. Aquí tomamos como referencia la multiplicidad del elemento. Lo que comúnmente conocerías en Bases de Datos como Relaciones uno a muchos.</p><p><img src=img/OOP/UML-agregacion2.jpg alt="Clases en UML"></p><p>Con esto decimos que la ClaseA contiene varios elementos de la ClaseB. Estos últimos son comúnmente representados con listas o colecciones de datos.</p><h3 id=composición>Composición<a class=anchor href=#composición>#</a></h3><p><img src=img/OOP/UML-composicion.jpg alt="Clases en UML"></p><p>Este es similar al anterior solo que su relación es totalmente compenetrada de tal modo que conceptualmente una de estás clases no podría vivir si no existiera la otra.</p><p><img src=img/OOP/UML-composicion2.jpg alt="Clases en UML"></p><h1 id=analisis-del-problema>Analisis del problema</h1><h2 id=modularidad>Modularidad<a class=anchor href=#modularidad>#</a></h2><p>La <strong>modularidad</strong> va muy relacionada con las clases y es un principio de la Programación Orientado a Objetos y va de la mano con el <strong>Diseño Modular</strong> que significa dividir un sistema en partes pequeñas y estas serán nuestros módulos pudiendo funcionar de manera independiente.</p><p>La modularidad de nuestro código nos va a permitir</p><ul><li>Reutilizar</li><li>Evitar colapsos</li><li>Hacer nuestro código más mantenible</li><li>Legibilidad</li><li>Resolución rápida de problemas</li></ul><p>Y esto lo logramos a traves de <strong>clases</strong>. Las clases nos permitiran:</p><ul><li>Tener Modularidad</li><li>Diviciones del programa en diferentes partes o módulos/clases.</li><li>Separar las clases en archivos.</li></ul><p>Una <strong>buena práctica</strong> es separando las clases en archivos diferentes.</p><h2 id=objetos>Objetos<a class=anchor href=#objetos>#</a></h2><p>Cuando tengamos un problema lo primero que debemos hacer es observar e <strong>itentificar los Objetos.</strong> Esto imaginandonos en un contexdo de dicho problema.</p><p>Los Objetos son aquellos que tienen propiedades y comportamientos, también serán sustantivos.</p><ul><li>Pueden ser Físicos(Manzana, carro, usuario, etc) o Conceptuales(dia, sesion de usuario, cuenta bancaria).</li></ul><p>Las <strong>Propiedades</strong> también pueden llamarse atributos y estos también serán sustantivos. Algunos atributos o propiedades son nombre, tamaño, forma, estado, etc. Son todas las características del objeto.</p><p>Los <strong>Comportamientos</strong> serán todas las operaciones que el objeto puede hacer, suelen ser verbos o sustantivos y verbo. Algunos ejemplos pueden ser que el usuario pueda hacer login y logout.</p><h2 id=abstracción-y-clases>Abstracción y clases<a class=anchor href=#abstracción-y-clases>#</a></h2><p>Una Clase sera el modelo(molde) por el cual nuestros objetos se van a construir y nos van a permitir generar más objetos.</p><p><strong>Analizamos Objetos para crear Clases</strong>. Las Clases son los modelos sobres los cuales construiremos nuestros objetos.</p><p><strong>Abstracción</strong> es cuando separamos los datos de un objeto para generar un molde.</p><h2 id=ejemplo>Ejemplo<a class=anchor href=#ejemplo>#</a></h2><p>A continuacion se muestra el analisis y modelado de un objeto <strong>Uber</strong>.</p><h3 id=analisis>Analisis<a class=anchor href=#analisis>#</a></h3><p>![Analisis de Uber](img/OOP/analisis-uber.png</p><h3 id=modelado>Modelado<a class=anchor href=#modelado>#</a></h3><p><img src=img/OOP/modelado-uber.png alt="Modelado de Uber"></p><p><img src=img/OOP/modelado-uber2.png alt="Modelado de Uber"></p><h1 id=herencia-1>Herencia</h1><p>La <strong>herencia</strong> nos permite crear nuevas clases a partir de otras, se basa en modelos y conceptos de la vida real. También tenemos una <strong>relacion</strong> jerarquía de <strong>padre e hijo</strong>.
La clase padre(Súperclase) debera ser la abstraccion mas general de un objetos.</p><p><strong>Don&rsquo;t Repeat Yourself</strong>. Una forma de identificar herencias es cuando estamos en la presencia de varias clases que comparten los mismos atributos y/o comportamientos. Al se detecta una relacion entre estos objetos se procede a la creacion de una SúperClass de las cuales estas heredaran.</p><p><strong>Ejemplo:</strong></p><p><img src=img/OOP/herencia-uber.png alt="user and driver"></p><p><img src=img/OOP/herencia-uber1.png alt="user and driver"></p><p><img src=img/OOP/herencia-uber2.png alt="user and driver"></p><p><img src=img/OOP/diagrama.jpg alt="user and driver"></p><h1 id=objetos-1>Objetos</h1><p>Los objetos nos ayudan a crear <strong>instancia</strong> de una clase, el objeto es el resultado de lo que modelamos, de los parámetros declarados y usaremos los objetos para que nuestras clases cobren vida.</p><p>Los <strong>métodos constructores</strong> dan un estado inicial al objeto y podemos añadirle algunos datos al objeto mediante estos métodos. Los atributos o elementos que pasemos a través del constructor serán los datos mínimos que necesita el objeto para que pueda vivir.</p></article><div class=pagination><a class=pagination__item href=https:///jmillandev.github.io/apuntes/python/><span class=pagination__label>Previous Post</span>
<span class=pagination__title></span></a><a class=pagination__item href=https:///jmillandev.github.io/apuntes/node/><span class=pagination__label>Next Post</span>
<span class=pagination__title></a></a></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"jmillandev"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=post__footer><div class=social-icons><a class=social-icons__link title=Twitter href=https://twitter.com/jmillandev target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/twitter.svg)></div></a><a class=social-icons__link title=GitHub href=https://github.com/jmillandev target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/github.svg)></div></a><a class=social-icons__link title=LinkedIn href=https://www.linkedin.com/in/jmillandev-42664412a/ target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/linkedin.svg)></div></a></div><p>© 2022</p></footer></div></div></div></main><script src=/jmillandev.github.io/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr+kQ=" crossorigin=anonymous></script><script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script><script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script></body></html>