<!doctype html><html lang=es-es><head><title>| Jesús Millán</title><meta charset=utf-8><meta name=language content="en"><meta name=description content><meta name=keywords content><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content><meta name=twitter:site content="@jmillandev"><meta name=twitter:creator content="https://twitter.com/jmillandev"><link rel="shortcut icon" type=image/png href=/favicon.ico><link type=text/css rel=stylesheet href=/jmillandev.github.io/css/post.min.2cb93c91050d1853bf971cc31e00122edd6e0f405aa1de3b7f8ef67ea3b5a79a.css integrity="sha256-LLk8kQUNGFO/lxzDHgASLt1uD0Baod47f472fqO1p5o="><link type=text/css rel=stylesheet href=/jmillandev.github.io/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/\/jmillandev.github.io\/apuntes\/python\/","name":"","author":{"@type":"Person","name":""},"description":""}</script></head><body><div class=burger__container><div class=burger aria-controls=navigation aria-label=Menu><div class="burger__meat burger__meat--1"></div><div class="burger__meat burger__meat--2"></div><div class="burger__meat burger__meat--3"></div></div></div><nav class=nav id=navigation><ul class=nav__list><li><a href=/jmillandev.github.io/>About</a></li><li><a class=active href=/jmillandev.github.io/apuntes/>Apuntes</a></li><li><a href=/jmillandev.github.io/blog/>Blog</a></li></ul></nav><main><style>@media(min-width:1024px){.post{width:85%;margin:0 auto;max-width:100%}}</style><div class=flex-wrapper><div class=post__container><div class=post><header class=post__header><h1 id=post__title></h1></header><article class=post__content><h1 id=qué-es-python>¿Qué es Python?</h1><p>Python es un lenguaje de programación creado por <a href=https://en.wikipedia.org/wiki/Guido_van_Rossum>Guido Van Rossum</a>, con una sintaxis muy limpia, ideado para enseñar a la gente a programar bien. Se trata de un lenguaje interpretado o de script.</p><h2 id=ventajas>Ventajas<a class=anchor href=#ventajas>#</a></h2><ul><li>Legible: sintaxis intuitiva y estricta.</li><li>Productivo: ahorra mucho código.</li><li>Portable: para todo sistema operativo.</li><li>Recargado: viene con muchas librerías por defecto.</li></ul><p>Editor recomendado: Atom o Sublime Text.</p><h2 id=instalación>Instalación<a class=anchor href=#instalación>#</a></h2><p>Existen dos versiones de Python que tienen gran uso actualmente, Python 2.x y Python 3.x.</p><p>Es <strong>recomentado utilizar la versión 3.x</strong> dado a que la versión 2.x dejara de tener soporte a partir del 2019.</p><p>Para instalar Python solo debes seguir los pasos dependiendo del sistema operativo que tengas instalado.</p><h3 id=windows>Windows<a class=anchor href=#windows>#</a></h3><p>Para instalar Python en Windows ve al <a href=URL title=https://www.python.org/downloads/>sitio</a> y presiona sobre el botón Download Python 3.7.3</p><p>Se descargará un archivo de instalación con el nombre python-3.7.3.exe , ejecútalo. Y sigue los pasos de instalación.</p><p>Al finalizar la instalación haz lo siguiente para corroborar una instalación correcta</p><p>Presiona las teclas <em><strong>Windows + R</strong></em> para abrir la ventana de Ejecutar.
Una vez abierta la ventana Ejecutar escribe el comando cmd y presiona <em><strong>ctrl+shift+enter</strong></em> para ejecutar una línea de comandos con permisos de administrador.
Windows te preguntará si quieres abrir el Procesador de comandos de Windows con permisos de administrador, presiona sí.
En la línea de comandos escribe <em><strong>python</strong></em>
Tu consola se mostrará así.
<img src=URL alt="captura de pantalla win cmd" title=./img/python/win.jpg></p><p>¡Ya estás listo para continuar con el curso!</p><h3 id=macos>MacOS<a class=anchor href=#macos>#</a></h3><p>La forma sencilla es tener instalado <a href=URL title=https://brew.sh/>homebrew</a> y usar el comando:</p><p><strong>Para instalar la Versión 2.7</strong></p><p><code>brew install python</code></p><p><strong>Para instalar la Versión 3.x</strong></p><p><code>brew install python3</code></p><h3 id=linux>Linux<a class=anchor href=#linux>#</a></h3><p>Generalmente Linux ya lo trae instalado, para comprobarlo puedes ejecutar en la terminal el comando</p><p><strong>Versión 2.7</strong></p><p><code>python -v</code></p><p><strong>Versión 3.x</strong></p><p><code>python3 -v</code></p><p>Si el comando arroja un error quiere decir que no lo tienes instalado, en ese caso los pasos para instalarlo cambian un poco de acuerdo con la distribución de linux que estés usando. Generalmente el gestor de paquetes de la distribución de Linux tiene el paquete de Python</p><p><strong>Si eres usuario de Ubuntu o Debian por ejemplo puedes usar este comando para instalar la versión 3.1:</strong></p><p><code>$ sudo apt-get install python3.1</code></p><p><strong>Si eres usuario de Red Hat o Centos por ejemplo puedes usar este comando para instalar python</strong></p><p><code>$ sudo yum install python</code></p><p>Si usas otra distribución o no has podido instalar python en tu sistema Linux dejame un comentario y vemos tu caso específico.</p><p>Si eres usuario habitual de linux también puedes <a href=URL title=https://www.python.org/downloads/source/>descargar los archivos</a> para instalarlo manualmente.</p><h2 id=antes-de-empezar>Antes de empezar:<a class=anchor href=#antes-de-empezar>#</a></h2><p>Para usar Python debemos tener un editor de texto abierto y una terminal o cmd (línea de comandos en Windows) como administrador.</p><p>Para ejecutar Python abre la terminal y escribimos:</p><p><code>python</code></p><p>Te abrirá una consola de Python, lo notarás porque el <em>prompt</em> cambia y ahora te muestra tres simbolos de mayor que “ &#187;> “ y el puntero adelante indicando que puedes empezar a ingresar comandos de python.</p><p><code>>>></code></p><p>En éste modo puedes usar todos los comandos de Python o escribir código directamente.</p><p>*Si deseas ejecutar código de un archivo sólo debes guardarlo con extension.py y luego ejecutar en la terminal:</p><p><code>$ python archivo.py</code></p><p>Ten en cuenta que para ejecutar el archivo con extensión “.py” debes estar ubicado en el directorio donde tienes guardado el archivo.</p><p><strong>Para salir de Python</strong> y regresar a la terminal debes usar el comando <code>exit()</code></p><p>Cuando usamos Python debemos atender ciertas reglas de la comunidad para definir su estructura. Las encuentras en el libro <a href=URL title=https://www.python.org/dev/peps/pep-0008/>PEP8</a>.</p><h1 id=consola>Consola</h1><h2 id=interaccion>Interaccion<a class=anchor href=#interaccion>#</a></h2><ul><li><p><strong>Output</strong>: print(&lsquo;Hello world&rsquo;)</p></li><li><p><strong>Input</strong>: var = input(&lsquo;message of input&rsquo;)</p></li></ul><h2 id=main>Main<a class=anchor href=#main>#</a></h2><p>Cada ves que ejecutamos un script esta presente la variable <strong><strong>name</strong></strong>, esta retornara el nombre del modulo en el caso de que este se importado desde otro script. Y retornara el valor &lsquo;<strong>main</strong>&rsquo; en el caso de que nos encontremos en el modulo que fue ejecutados desde la CLI. Es decir, Cuando ejecutamos un script desde la terminal, la variable <strong><strong>name</strong></strong> obtiene el valor de &ldquo;<strong>main</strong>". De esta manera cuando deseemos ejecutar un codigo SOLO si el modulo es ejecutado(no importado). Lo estructuraremos de la siguiente manera:</p><pre><code class=language-python># Todas las funciones y codigo necesario para el programa.

if __name__ == '__main__':
    #esto es lo que se ejecutara en el programa por defecto, algo asi como el index en la web.
</code></pre><h1 id=sintaxis-y-nomenclaura>Sintaxis y Nomenclaura</h1><h2 id=indentacion>Indentacion<a class=anchor href=#indentacion>#</a></h2><p>a diferencia de otros lenguajes de programacion no se utilizan {} para escribir un bloque de codigo. Los bloque de codigo son tabulados con una sangria de 4</p><h2 id=comentarios>Comentarios<a class=anchor href=#comentarios>#</a></h2><h3 id=lineal>Lineal<a class=anchor href=#lineal>#</a></h3><p>para comentar una linea utilizamos el caracter &lsquo;#'.
Ej:
<code>#Esto es un comentario</code></p><h2 id=buenas-practicas>Buenas Practicas<a class=anchor href=#buenas-practicas>#</a></h2><h3 id=entre-linea>Entre linea<a class=anchor href=#entre-linea>#</a></h3><p>Dejar dos lineas de espacio entre declaracion de funciones</p><h3 id=variables>Variables<a class=anchor href=#variables>#</a></h3><ul><li><p>Son escritas en &ldquo;snake-case&rdquo;.
Ej:
<code>my_var = 5</code></p></li><li><p>Visibilidad
En python <em>todas</em> las variables son visibles, aunque existe una sintaxis para diferencias, las variables, publicas, privadas y mega privada(estas jamas deben tocarse, de modificarse pueden comprometer el usu del software).</p></li></ul><p><strong>public</strong>: <code>my_var</code></p><p><strong>private</strong>: <code>_my_var_private</code></p><p><strong>do_not_touch</strong>: <code>__my_var_special</code></p><h3 id=constantes>Constantes<a class=anchor href=#constantes>#</a></h3><p>Se escriben en UpperCase.
Ej:
<code>PI = 3.14</code></p><h1 id=operadores>Operadores</h1><h2 id=matematicos>Matematicos<a class=anchor href=#matematicos>#</a></h2><ul><li><strong>+</strong>: Suma.</li><li><strong>-</strong>: Resta.</li><li><strong>/</strong>: Division.</li><li><strong>//</strong>: Division entera.</li><li><strong>%</strong>: Modulo o residuo.</li><li><strong>*</strong>: Multiplicacion.</li><li><strong>**</strong>: Potencia.</li></ul><h2 id=asignacion>Asignacion<a class=anchor href=#asignacion>#</a></h2><p>Son utilizados para hacer asignaciones a las variables:</p><ul><li><strong>=</strong>: Asignar. Ej:</li></ul><pre><code class=language-python> &gt;&gt;&gt; a = 10
 &gt;&gt;&gt; a
 10
</code></pre><ul><li><strong>+=</strong>: Sumar y asignar. Ej:</li></ul><pre><code class=language-python> &gt;&gt;&gt; a = 10
 &gt;&gt;&gt; a += 5
 &gt;&gt;&gt; a
 15
</code></pre><ul><li><strong>-=</strong>: Restar y asignar. Ej:</li></ul><pre><code class=language-python> &gt;&gt;&gt; a = 10
 &gt;&gt;&gt; a -= 5
 &gt;&gt;&gt; a
 5 
</code></pre><ul><li><strong>/=</strong>: Dividir y asignar. Ej:</li></ul><pre><code class=language-python>&gt;&gt;&gt; a = 10
&gt;&gt;&gt; a /= 3
&gt;&gt;&gt; a
3.333 
</code></pre><ul><li><strong>//=</strong>: Division Entera y asignar. Ej:</li></ul><pre><code class=language-python>&gt;&gt;&gt; a = 10
&gt;&gt;&gt; a //= 3
&gt;&gt;&gt; a
3
</code></pre><ul><li><strong>%=</strong>: Modulo y asignar. Ej:</li></ul><pre><code class=language-python>&gt;&gt;&gt; a = 10
&gt;&gt;&gt; a %= 3
&gt;&gt;&gt; a
1
</code></pre><ul><li><strong>*=</strong>: Multiplicar y asignar. Ej:</li></ul><pre><code class=language-python>&gt;&gt;&gt; a = 10
&gt;&gt;&gt; a *= 3
&gt;&gt;&gt; a
30
</code></pre><ul><li><strong>**=</strong>: Sacar potencia y asignar. Ej:</li></ul><pre><code class=language-python>&gt;&gt;&gt; a = 2
&gt;&gt;&gt; a **= 8
&gt;&gt;&gt; a
256
</code></pre><ul><li><strong>or</strong>: si el valor a la izquierda es (nulo, falso o vacio) asigna el valor a la derecha. Ej:</li></ul><pre><code class=language-python> &gt;&gt;&gt; a = False
 &gt;&gt;&gt; b = a or 50
 &gt;&gt;&gt; b
 50 
</code></pre><h2 id=comparacion>Comparacion<a class=anchor href=#comparacion>#</a></h2><p>Nos sirven para comparar valores:</p><ul><li><strong>==</strong>: Igual.</li><li><strong>!=</strong>: Distinto.</li><li><strong>></strong>: Mayor que.</li><li><strong>&lt;</strong>: Menor que.</li><li><strong>>=</strong>: Mayor o igual que.</li><li><strong>&lt;=</strong>: Menor o igual que.</li></ul><h2 id=logicos>Logicos<a class=anchor href=#logicos>#</a></h2><p>Junto con los operadores de comparacion nos sirver para hacer preguntas logicas.</p><ul><li><strong>and</strong>: Y.</li><li><strong>or</strong>: O.</li><li><strong>not</strong>: No o Negacion.</li></ul><h1 id=tipos-de-datos-en-python>Tipos de datos en Python</h1><ol><li><strong>Enteros (int)</strong>: en este grupo están todos los números, enteros y <em>long</em>:</li></ol><p><em>ejemplo</em>: 1, 2121, 2192, -123</p><ol start=2><li><strong>Flotantes (float)</strong>: en este grupo están todos los números con coma flotante o decimales:</li></ol><p><em>ejemplo</em>: 1.0, -12.3</p><ol start=3><li><p><strong>Booleanos (bool)</strong>: Son los valores <em>falso</em> o <em>verdadero</em>, compatibles con todas las operaciones booleanas ( and, not, or ):
<em>ejemplo</em>: True, False</p></li><li><p><strong>Cadenas (str)</strong>: Son una cadena de texto :
<em>ejemplos</em>: “Hola”, “¿Cómo estas?”</p></li><li><p><strong>Listas</strong>: Son un grupo o array de datos, puede contener cualquiera de los datos anteriores:
<em>ejemplos</em>: [1,2,3, ”hola” , [1,2,3] ], [1,“Hola”,True ]</p></li><li><p><strong>Diccionarios</strong>: Son un grupo de datos que se acceden a partir de una <em>clave</em>:
<em>ejemplo</em>: {“clave”:”valor”}, {“nombre”:”Fernando”}</p></li><li><p><strong>Tuplas</strong>: también son un grupo de datos igual que una lista con la diferencia que una tupla después de creada no se puede modificar(Son inmutables).
<em>ejemplos</em>: [1,2,3, ”hola” , [1,2,3] ], [1,“Hola”,True ] <em><strong>(Pero jamás podremos cambiar los elementos dentro de esa Tupla)</strong></em></p></li></ol><p>En Python trabajas con <strong>módulos</strong> y <strong>ficheros</strong> que usas para importar las librerías.</p><h1 id=funciones>Funciones</h1><p>En el contexto de la programación, una función es una secuencia enunciados (statements) con un nombre que realizan un cómputo. Una función tiene un nombre, parámetros (opcional) y valor de regreso(return value)(opcional).</p><p>Las funciones las defines con <strong>def</strong> junto a un nombre y unos paréntesis que reciben los parámetros a usar. Terminas con dos puntos.</p><p><code>def nombre_de_la_función(parametros):</code></p><p>Después por indentación colocas los datos que se ejecutarán desde la función:</p><pre><code class=language-python> &gt;&gt;&gt; def my_first_function():
 ...	return “Hello World!” 
 ...    
 &gt;&gt;&gt; my_first_function()
Hello World!
</code></pre><p>Python incluye varias built-in functions en su librería estándar(recuerda que puedes utilizar la funcion &ldquo;<strong>help(func)</strong>&rdquo; para examinar el comportamiento de dicha function o visitar el <a href=URL title=https://docs.python.org/3/library/functions.html>sitio web oficial</a> :</p><h2 id=built-in-funtions-funciones-integradas>Built-in funtions (Funciones integradas)<a class=anchor href=#built-in-funtions-funciones-integradas>#</a></h2><ol><li>abs()</li><li>delattr()</li><li>hash()</li><li>memoryview()</li><li>set()</li><li>all()</li><li>dict()</li><li>help()</li><li>min()</li><li>setattr()</li><li>any()</li><li>dir()</li><li>hex()</li><li>next()</li><li>slice()</li><li>ascii()</li><li>divmod()</li><li>id()</li><li>object()</li><li>sorted()</li><li>bin()</li><li>enumerate()</li><li>input()</li><li>oct()</li><li>staticmethod()</li><li>bool()</li><li>eval()</li><li>int()</li><li>open()</li><li>str()</li><li>breakpoint()</li><li>exec()</li><li>isinstance()</li><li>ord()</li><li>sum()</li><li>bytearray()</li><li>filter()</li><li>issubclass()</li><li>pow()</li><li>super()</li><li>bytes()</li><li>float()</li><li>iter()</li><li>print()</li><li>tuple()</li><li>callable()</li><li>format()</li><li>len()</li><li>property()</li><li>type()</li><li>chr()</li><li>frozenset()</li><li>list()</li><li>range()</li><li>vars()</li><li>classmethod()</li><li>getattr()</li><li>locals()</li><li>repr()</li><li>zip()</li><li>compile()</li><li>globals()</li><li>map()</li><li>reversed()</li><li><strong>import</strong>()</li><li>complex()</li><li>hasattr()</li><li>max()</li><li>round()</li></ol><h1 id=constantes-1>Constantes</h1><p>Las constantes en <strong>python</strong> en realidad son variables con un nomenclatura distinta(ver la seccion de <strong>Sintaxis y Nomenclatura</strong>).</p><h1 id=variables-1>Variables</h1><p>Las variables, a diferencia de los demás lenguajes de programación, no debes definirlas, ni tampoco su tipo de dato, ya que al momento de iterarlas se identificará su tipo. Recuerda que en Python todo es un objeto.</p><pre><code class=language-python> A = 3 
 B = A
</code></pre><h2 id=cadenas>Cadenas<a class=anchor href=#cadenas>#</a></h2><p>Los String son declaradas entre comillas simples('') o doble(""). Son inmutables.</p><h3 id=metodos>Metodos<a class=anchor href=#metodos>#</a></h3><ul><li><p><strong>upper()</strong>: Convierte todo a mayusculas.</p></li><li><p><strong>lower()</strong>: Convierte todo la cadena a minusculas.</p></li><li><p><strong>find(&lsquo;patron&rsquo;)</strong>: Encuentra el indice con empieza el &lsquo;patron&rsquo; que definimos, retorna un entero.</p></li><li><p><strong>startswich(&lsquo;patron&rsquo;)</strong>: Que empieza con &lsquo;patron&rsquo;, retorna un booleano.</p></li><li><p><strong>endtswich(&lsquo;patron&rsquo;)</strong>: Que termina con &lsquo;patron&rsquo;, retorna un booleano.</p></li><li><p><strong>capitalize()</strong>: Regresa la cadena con el primer caracter en mayusculas y el resto en minusculas.</p></li><li><p><strong>slice</strong>: regresa una &ldquo;rebanada&rdquo; de la cadena, la sintaxis es:</p></li></ul><p><code>var[inicio:fin:pasos]</code></p><h2 id=estructuras-de-datos>Estructuras de Datos<a class=anchor href=#estructuras-de-datos>#</a></h2><h3 id=listas>Listas<a class=anchor href=#listas>#</a></h3><p>Las listas las declaras con corchetes. Estas pueden tener una lista dentro o cualquier tipo de dato.</p><pre><code class=language-python> &gt;&gt;&gt; L = [22, True, ”una lista”, [1, 2]]
 &gt;&gt;&gt; L_none = list() 
 &gt;&gt;&gt; L[0] 
 22
</code></pre><h4 id=metodos-1>Metodos</h4><ul><li><p><strong>L.append(elemento)</strong>: agrega un elemento a lista.</p></li><li><p><strong>L.pop(uid)</strong>: retorna el elemento con el id = uid y lo elimina de la lista, por defecto uid es el del ultimo elemento.</p></li><li><p><strong>L.sort</strong>: Ordena la lista.</p></li><li><p><strong>remove</strong>: Si sabes qué elemento quieres eliminar, pero no su índice, puedes utilizar este metodo.</p></li><li><p><strong>del lista[elemento]</strong>: Para eliminar elementos. También lo podemos utilizar con slices.</p></li><li><p><strong>sorted()</strong>:</p></li></ul><h3 id=diccionarios>Diccionarios<a class=anchor href=#diccionarios>#</a></h3><p>En los diccionarios tienes un grupo de datos con un formato:
la primera es una <strong>cadena o número</strong> que será la clave para acceder al segundo dato, el segundo dato será el <strong>valor</strong> al cual accederás con la llave. Recuerda que los diccionarios son listas de llave:valor.</p><p><em>Los diccionarios se inicializan con {} o con la función dict</em></p><pre><code class=language-python> &gt;&gt;&gt; D = {&quot;Kill Bill&quot;: &quot;Tamarino&quot;, &quot;Amelie&quot;: &quot;Jean-Pierre Jeunet&quot;} 
 &gt;&gt;&gt; D[&quot;Kill Bill&quot;]
 &quot;Tamarino&quot;
</code></pre><h4 id=metodos-2>Metodos</h4><h4 id=iterables>Iterables</h4><ul><li><strong>D.keys()</strong>: genera un elemento iterable a traves de las llaves o keys</li><li><strong>D.values()</strong>: genera un elemento iterable a traves de los valores del diccionario.</li><li><strong>D.items()</strong>: genera un elemento iterable a traves de las claves : valores del diccionario.</li></ul><h3 id=tuplas>Tuplas<a class=anchor href=#tuplas>#</a></h3><p>Las tuplas son similares a las listas. Estas se declaran con paréntesis, recuerda que no puedes editar los datos de una tupla después de que la has creado pues son inmutables.</p><pre><code class=language-python> &gt;&gt;&gt; T = (22, True, &quot;una tupla&quot;, (1, 2))
 &gt;&gt;&gt; T_none = tuple() 
 &gt;&gt;&gt; T[0] 
 22
</code></pre><h3 id=set-o-conjuntos>Set o Conjuntos<a class=anchor href=#set-o-conjuntos>#</a></h3><p>Los conjuntos son elementos sin orden y no permiten elementos repetidos.</p><pre><code class=language-python> &gt;&gt;&gt; S = set()
 &gt;&gt;&gt; s.add(5)
 {5}
</code></pre><h4 id=metodos-3>Metodos</h4><ul><li><strong>add</strong>: para agregar un nuevo elemento al conjunto.</li><li><strong>remove</strong>: para eliminar un elemento del conjuntos.</li></ul><h1 id=conversiones>Conversiones</h1><ul><li>De flotante a entero:</li></ul><pre><code class=language-python> &gt;&gt;&gt; int(4.3)
 4
</code></pre><ul><li>De entero a flotante:</li></ul><pre><code class=language-python> &gt;&gt;&gt; float(4) 
 4.0
</code></pre><ul><li>De entero a string:</li></ul><pre><code class=language-python> &gt;&gt;&gt; str(4.3) 
 &quot;4.3&quot;
</code></pre><ul><li>De tupla a lista:</li></ul><pre><code class=language-python> &gt;&gt;&gt; list((4, 5, 2)) 
 [4, 5, 2]
</code></pre><h1 id=operadores-comunes>Operadores Comunes</h1><h2 id=longitud-de-una-cadena-lista-tupla-etc>Longitud de una cadena, lista, tupla, etc.:<a class=anchor href=#longitud-de-una-cadena-lista-tupla-etc>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; len(&quot;key&quot;) 
 3
</code></pre><h2 id=tipo-de-dato>Tipo de dato:<a class=anchor href=#tipo-de-dato>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; type(4) 
 &lt; type int &gt;
</code></pre><h2 id=aplicar-una-conversión-a-un-conjunto-como-una-lista>Aplicar una conversión a un conjunto como una lista:<a class=anchor href=#aplicar-una-conversión-a-un-conjunto-como-una-lista>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; map(str, [1, 2, 3, 4])
 ['1', '2', '3', '4']
</code></pre><h2 id=redondear-un-flotante-con-x-número-de-decimales>Redondear un flotante con x número de decimales:<a class=anchor href=#redondear-un-flotante-con-x-número-de-decimales>#</a></h2><pre><code class=language-python>&gt;&gt;&gt; round(6.3243, 1)
 6.3
</code></pre><h2 id=generar-un-rango-en-una-lista-esto-es-mágico>Generar un rango en una lista (esto es mágico):<a class=anchor href=#generar-un-rango-en-una-lista-esto-es-mágico>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; range(5) 
 [0, 1, 2, 3, 4]
</code></pre><h2 id=sumar-un-conjunto>Sumar un conjunto:<a class=anchor href=#sumar-un-conjunto>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; sum([1, 2, 4]) 
 7
</code></pre><h2 id=organizar-un-conjunto>Organizar un conjunto:<a class=anchor href=#organizar-un-conjunto>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; sorted([5, 2, 1]) 
 [1, 2, 5]
</code></pre><h2 id=operadores-de-pertenencia>Operadores de Pertenencia:<a class=anchor href=#operadores-de-pertenencia>#</a></h2><p>Se utilizan para verificar si un valor esta dentro de un iterable, retornan un booleano:</p><ul><li>in</li><li>not in</li></ul><h2 id=conocer-los-comandos-que-le-puedes-aplicar-a-x-tipo-de-datos>Conocer los comandos que le puedes aplicar a x tipo de datos:<a class=anchor href=#conocer-los-comandos-que-le-puedes-aplicar-a-x-tipo-de-datos>#</a></h2><pre><code class=language-python> &gt;&gt;&gt;Li = [5, 2, 1]
 &gt;&gt;&gt;dir(Li)
 &gt;&gt;&gt;['append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre><p><em>‘append’, ‘count’, ‘extend’, ‘index’, ‘insert’, ‘pop’, ‘remove’, ‘reverse’, ‘sort’</em> son posibles comandos que puedes aplicar a una lista.</p><h2 id=información-sobre-una-función-o-librería>Información sobre una función o librería:<a class=anchor href=#información-sobre-una-función-o-librería>#</a></h2><pre><code class=language-python> &gt;&gt;&gt; help(sorted) 
 (Aparecerá la documentación de la función sorted)
</code></pre><p>#Clases</p><p>Clases es uno de los conceptos con más definiciones en la programación, pero en resumen sólo son la representación de un objeto. Para definir la clase usas <em><strong>class</strong></em> y el nombre. En caso de tener parámetros los pones entre paréntesis.</p><p>Para crear un constructor haces una función dentro de la clase con el nombre <em><strong><strong>init</strong></strong></em> y de parámetros self (significa su clase misma), nombre_r y edad_r:</p><pre><code class=language-python> &gt;&gt;&gt; class Estudiante(object): 
 ... 	def __init__(self,nombre_r,edad_r): 
 ... 		self.nombre = nombre_r 
 ... 		self.edad = edad_r 
 ...
 ... 	def hola(self): 
 ... 		return &quot;Mi nombre es %s y tengo %i&quot; % (self.nombre, self.edad) 
 ... 
 &gt;&gt;&gt; e = Estudiante(“Arturo”, 21) 
 &gt;&gt;&gt; print (e.hola())
 Mi nombre es Arturo y tengo 21
</code></pre><p>Lo que hicimos en las dos últimas líneas fue:</p><ol><li><p>En la variable llamamos la clase Estudiante y le pasamos la cadena “Arturo” y el entero 21.</p></li><li><p>Imprimimos la función hola() dentro de la variable e (a la que anteriormente habíamos pasado la clase).</p></li></ol><p>Y por eso se imprime la cadena “Mi nombre es Arturo y tengo 21”</p><h1 id=métodos-especiales>Métodos especiales</h1><h2 id=cmpselfotro>cmp(self,otro)<a class=anchor href=#cmpselfotro>#</a></h2><p>Método llamado cuando utilizas los operadores de comparación para comprobar si tu objeto es menor, mayor o igual al objeto pasado como parámetro.</p><h2 id=lenself>len(self)<a class=anchor href=#lenself>#</a></h2><p>Método llamado para comprobar la longitud del objeto. Lo usas, por ejemplo, cuando llamas la función len(obj) sobre nuestro código. Como es de suponer el método te debe devolver la longitud del objeto.</p><h2 id=initselfotro>init(self,otro)<a class=anchor href=#initselfotro>#</a></h2><p>Es un constructor de nuestra clase, es decir, es un “método especial” que se llama automáticamente cuando creas un objeto.</p><h1 id=iterators-and-generators>Iterators and generators</h1><h2 id=iterators>Iterators<a class=anchor href=#iterators>#</a></h2><p>Un iterator es simplemente un objeto que cumple con los requisitos del Iteration Protocol (protocolo de iteración) y por lo tanto puede ser utilizado en ciclos. Por ejemplo,</p><pre><code class=language-python>for i in range(10):
    print(i)
</code></pre><p>En este caso, la función range es un iterable que regresa un nuevo valor en cada ciclo. Para crear un objeto que sea un iterable, y por lo tanto, implemente el protocolo de iteración, debemos hacer tres cosas:</p><ol><li><p>Crear una clase que implemente los métodos <strong>iter</strong> y <strong>next</strong>.</p></li><li><p><strong>iter</strong> debe regresar el objeto sobre el cual se iterará.</p></li><li><p><strong>next</strong> debe regresar el siguiente valor y <em>aventar la excepción StopIteration</em> cuando ya no hayan elementos sobre los cual iterar.</p></li></ol><h2 id=generators>Generators<a class=anchor href=#generators>#</a></h2><p>Los generators son simplemente una forma rápida de crear iterables sin la necesidad de declarar una clase que implemente el protocolo de iteración. Para crear un generator simplemente declaramos una función y utilizamos el keyword <strong>yield</strong> en vez de return para regresar el siguiente valor en una iteración. Por ejemplo,</p><pre><code class=language-python>def fibonacci(max):
    a, b = 0, 1
    while a &lt; max:
        yield a
        a, b = b, a+b
</code></pre><p><em><strong>Es importante</strong></em> recalcar que una vez que se ha agotado un generator ya no podemos utilizarlo y debemos crear una nueva instancia. Por ejemplo,</p><pre><code class=language-python>fib1 = fibonacci(20)
fib_nums = [num for num in fib1]
...
double_fib_nums = [num * 2 for num in fib1] # no va a funcionar
double_fib_nums = [num * 2 for num in fibonacci(30)] # sí funciona
</code></pre><h1 id=comprehensions>Comprehensions</h1><p>Son constructos que nos permiten generar secuencias a partir de otras secuencias. Existen 3 tipos:</p><ul><li>List Comprehension</li></ul><p><strong>[</strong> element_to_add <strong>for</strong> element <strong>in</strong> element_list <strong>if</strong> element_meets_condition <strong>]</strong></p><ul><li>Dictionary Comprehension</li></ul><p><strong>{</strong> key_to_element:element_to_add <strong>for</strong> element <strong>in</strong> element_list <strong>if</strong> element_meets_condition <strong>}</strong></p><ul><li>Set Comprehension</li></ul><p><strong>{</strong> element_to_add <strong>for</strong> element <strong>in</strong> element_list <strong>if</strong> element_meets_condition <strong>}</strong></p><h1 id=condicionales-if>Condicionales IF</h1><p>Los condicionales tienen la siguiente estructura. Ten en cuenta que lo que contiene los paréntesis es la comparación que debe cumplir para que los elementos se cumplan.</p><pre><code class=language-python> if ( a &gt; b ):
 	elementos 
 elif ( a == b ): 
 	elementos 
 else:
 	elementos
</code></pre><h1 id=bucles>Bucles</h1><h2 id=for>FOR<a class=anchor href=#for>#</a></h2><p>El bucle de for lo puedes usar de la siguiente forma: recorres una cadena o lista a la cual va a tomar el elemento en cuestión con la siguiente estructura:</p><pre><code class=language-python> for i in ____:
 	elementos
</code></pre><p>Ejemplo:</p><pre><code class=language-python> for i in range(10):
 	print i
</code></pre><p>En este caso recorrerá una lista de diez elementos, es decir el <code>print i</code> debe ejecutarse diez veces. Ahora i va a tomar cada valor de la lista, entonces este for imprimirá los números del 0 al 9 (recordar que en un range vas hasta el número puesto -1).</p><h2 id=while>WHILE<a class=anchor href=#while>#</a></h2><p>En este caso while tiene una condición que determina hasta cuándo se ejecutará. O sea que dejará de ejecutarse en el momento en que la condición deje de ser cierta. La estructura de un while es la siguiente:</p><pre><code class=language-python> while (condición):
 	elementos
</code></pre><p>Ejemplo:</p><pre><code class=language-python> &gt;&gt;&gt; x = 0 
 &gt;&gt;&gt; while x &lt; 10: 
 ... 	print x 
 ... 	x += 1
</code></pre><p>En este ejemplo preguntará si es menor que diez. Dado que es menor imprimirá x y luego sumará una unidad a x. Luego x es 1 y como sigue siendo menor a diez se seguirá ejecutando, y así sucesivamente hasta que x llegue a ser mayor o igual a 10.</p><h2 id=operadores-1>Operadores<a class=anchor href=#operadores-1>#</a></h2><ul><li><p><strong>continue</strong>: se usa para saltarse los <em>statements</em> restantes y pasar a la siguiente iteracion.</p></li><li><p><strong>break</strong>: se sale del bucle.</p></li></ul><h1 id=manipulacion-de-archivos>Manipulacion de Archivos</h1><p>La función <strong>open</strong> nos permite leer archivos</p><p><code>f = open(‘some_file’)</code></p><p><strong>Es importante</strong> siempre cerrar el archivo con la función <strong>close</strong> para que se
escriban los datos y no se desperdicie memoria.</p><p>`f.close()``</p><p>Una mejor manera de manipular archivos y una buena practica es utilizando context managers,
porque garantizan que el archivo se cierre, Ej.</p><pre><code class=language-python>with open(filename) as f:
# do something with the file
</code></pre><h2 id=modos-para-abrir-un-archivo>Modos para abrir un archivo<a class=anchor href=#modos-para-abrir-un-archivo>#</a></h2><p>Existen varios modos de abrir un archivo. Los más importantes son r (read),
w (write), a (append).</p><pre><code class=language-python>with open(filename, mode=’w’) as f:
# do something with the file
</code></pre><h2 id=csv>CSV<a class=anchor href=#csv>#</a></h2><p>El modulo <strong>csv</strong> nos permite manipular archivos con extension <em>.csv</em>.</p><p>Para utilizarlo lo importamos con la declarcion:</p><p>`import csv``</p><p>Existen dos <strong>Reader</strong> y dos <strong>Writer</strong> que viene con el modulo que nos seran muy utilies.</p><ol><li><p><strong>csv.Reander and csv.Writer</strong>:
Nos permite manipular los valores a traves de listas que representan filas.</p></li><li><p><strong>csv.DictReader and cdv.DictWriter</strong>:
Nos permite manipular los valores a traves de diccionarios que representan filas.</p></li></ol><h1 id=decoradores>Decoradores</h1><p>Los decoradores permiten extender y modificar el funcionamiento de las
funciones. Estas envuelven a otra función y permiten ejecutar código antes y
después de que es llamada
Ejemplo de definicion de un decorador:</p><pre><code class=language-python>def lower_case(func):
	def wrapper():
		# execute code before
		result = func()
		# execute code after
		return result
	
	return wrapper
</code></pre><p><strong>Importante</strong>, la funcion donde vayamos a ejecutar el decorador debera estar predecedida por la llamada a el decorador ejemplo:</p><pre><code class=language-python>@lower_case()
def my_function (arg)
	pass
</code></pre><p><strong>Nota</strong>: Cuando declaramos la function aux wraper es comun pasarle como parametros (*arg,**kwargs). Ejemplo:</p><pre><code class=language-python>def lower_case(func):
	def wrapper(*arg,**kwargs):
		# execute code before
		result = func(*arg,**kwargs)
		# execute code after
		return result
	
	return wrapper
</code></pre><h1 id=oop-object-oriented-programming>OOP (Object Oriented Programming)</h1><p>La programación orientada a objetos es un paradigma de programación que
otorga los medios para estructurar programas de tal manera que las
propiedades y comportamientos estén envueltos en objetos individuales. En pocas palabras, es un enfoque que nos permite modelar objetos concretos, del mundo real y las relaciones entre ellos</p><p><strong>Principios básicos de OOP</strong>:</p><ul><li>Encapsulation</li><li>Abstraction</li><li>Inheritance</li><li>Polyphormism</li></ul><p>Todos los objetos son una instancia de una clase</p><p>Ejemplo:</p><pre><code class=language-python>class Airplane:
	def __init__(self, passengers, seats, pilots=[]):
		self.passengers = passengers
		self.seats = seats
		self._pilots = pilots
	def takeoff(self):
		pass


airplane = Airplane(passengers=20, seats=30, pilots=['Tom', 'Billy'])
airplane.passengers = 31
airplane.takeoff()
</code></pre><p>El metodo <strong><strong>init</strong></strong> es el constructur de la clase. El metodo constructor es aque que se ejecuta al crear una nueva instancia de la clase.</p><p>El parametro <strong>self</strong> es pasado como primer parametro en <em>TODOS</em> los metodos de las clases, este representa a la clase misma.</p><h1 id=collections-colecciones>Collections (Colecciones)</h1><p>El módulo collections nos brinda un conjunto de objetos primitivos que nos permiten <strong>extender</strong> el comportamiento de las <strong>built-in</strong> collections que poseé Python y nos otorga estructuras de datos adicionales.
Por ejemplo,</p><ul><li>Si queremos extender el comportamiento de un diccionario, podemos extender la clase <em>UserDict</em>.</li><li>Si queremos extender de una lista, extendemos <em>UserList</em>.</li><li>Para el caso de strings, utilizamos <em>UserString</em>.</li></ul><p>Por ejemplo, si queremos tener el comportamiento de un diccionario podemos escribir el siguiente código:</p><pre><code class=language-python>class SecretDict(collections.UserDict):

   def _password_is_valid(self, password):
        …

    def _get_item(self, key):
        … 

    def __getitem__(self, key):
         password, key = key.split(‘:’)
         
         if self._password_is_valid(password):
              return self._get_item(key)
         
         return None

my_secret_dict = SecretDict(...)
my_secret_dict[‘some_password:some_key’] # si el password es válido, regresa el valor
</code></pre><p>Otra estructura de datos que vale la pena analizar, es <strong>namedtuple</strong>. Usualmente utilizamos tuples que permiten acceder a sus valores a través de índices. Sin embargo, en ocasiones es importante poder nombrar elementos (en vez de utilizar posiciones) para acceder a valores y no queremos crear una clase ya que únicamente necesitamos un contenedor de valores y no comportamiento.</p><pre><code class=language-python>Coffee = collections.NamedTuple(‘Coffee’, (‘size’, ‘bean’, ‘price’))
def get_coffee(coffee_type):
     If coffee_type == ‘houseblend’:
         return Coffee(‘large’, ‘premium’, 10)
</code></pre><p>El módulo collections también nos ofrece otros primitivos que tienen la labor de facilitarnos la creación y manipulación de colecciones en Python. Por ejemplo,</p><p><strong>Counter</strong>: nos permite contar de manera eficiente ocurrencias en cualquier iterable. <strong>OrderedDict</strong>: nos permite crear diccionarios que poseen un orden explícito.
<strong>deque</strong> nos permite crear filas (para pilas podemos utilizar la lista).</p><p><em><strong>En conclusión</strong></em>, el módulo collections es una gran fuente de utilerías que nos permiten escribir código más “pythonico” y más eficiente.</p><h1 id=modulos>Modulos</h1><p>Si sales del intérprete de Python y entrás de nuevo, las definiciones que hiciste (funciones y variables) se pierden. Por lo tanto, si querés escribir un programa más o menos largo. Es mejor crear un script que el interprete luego ejecutara.</p><p>A medida que el progama va creciendo es comun ir separandolo en varios archivos para hacerlo mas practico y facil a la hora de mantenerlo.</p><p>Para soportar esto, Python tiene una manera de poner <em>definiciones</em> en un archivo y usarlos en un script o en una instancia interactiva del intérprete. Tal archivo es llamado <strong>módulo</strong>; las definiciones de un módulo pueden ser <em>importadas</em> a otros módulos o al módulo principal (la colección de variables a las que tienes acceso en un script ejecutadolo en el nivel superior y en el modo calculadora).</p><p>El <em>nombre del archivo es el nombre del módulo</em> con el sufijo <code>.py</code> agregado. Dentro de un módulo, el nombre del mismo (como una cadena) está disponible en el valor de la variable global <strong>name</strong>.</p><p>Para utilizar cualquier modulo deberemos importarlo con la siguiente linea de codigo(puede ser directamente desde la consola o en un script):</p><p><code>import model_name</code></p><p>Una vez importado el modulo para hacer referencia a las funciones, objetos, variables definidos en dicho modulo deberemos hacer referencia de la siguiente manera:</p><pre><code class=language-python>model_name.variable_name
model_name.function_name
model_name.class_name
</code></pre><p>Si requerimos solamente el uso de ciertos metodos, del modulo podriamos importar exclusivamente esa definicion de la siguiente manera:</p><pre><code class=language-python>from model_name import function

hola = funtion()
</code></pre><h1 id=librerias-externas>Librerias Externas</h1><p>Son codigos de 3eros que nos facilitan el trabajo al no &ldquo;reinvertar la rueda&rdquo;
Alguanas librerias son:</p><h2 id=os>OS<a class=anchor href=#os>#</a></h2><p>El modulo <strong>OS</strong> nos sera de mucha utilidad en la manupulacion de archivos ya que nos permite manipular el sistema operativo.</p><p>alguno de sus metodos son:</p><ul><li><p>os.remove(&lsquo;name_file&rsquo;): Nos permite borrar un archivo del disco duro.</p></li><li><p>os.rename(&lsquo;old_name_fiel&rsquo;,&lsquo;new_name_file&rsquo;).</p></li></ul><h2 id=openpyxl>openpyxl<a class=anchor href=#openpyxl>#</a></h2><p>Esta libreria nos permite la manipulacion de archivos en formato xls (hojas de calculo).</p><p>Codigo de interes:</p><ol><li>Lectura de archivos:</li></ol><pre><code class=language-python>from openpyxl import load_workbook

FILE_PATH = 'test.xlsx'
SHEET = 'Hoja 1'

workbook = load_workbook(FILE_PATH, read_only = True)
sheet = workbook[SHEET]


for row in sheetiter_rows(min_row=2)
    print(row[0].value)
    print(row[1].value)
    print(row[2].value)
</code></pre><p><em><strong>NOTA:</strong></em> El atributo min_row no es obligatorio, este indica a partir de cual fila comenzara al iteracion, para el ejemplo es la segunda fila. Por defecto es la primera</p><h1 id=scopes-and-namespace>Scopes and NameSpace</h1><p>En Python, un <strong>name</strong>, también conocido como <strong>identifier</strong>, es simplemente una forma de otorgarle un nombre a un objeto. Mediante el nombre, podemos acceder al objeto. Vamos a ver un ejemplo:</p><pre><code class=language-python>my_var = 5

id(my_var) # 4561204416
id(5) # 4561204416
</code></pre><p>En este caso, el <strong>identifier</strong> my_var es simplemente una forma de acceder a un objeto en memoria (en este caso el espacio identificado por el número 4561204416). Es importante recordar que un name puede referirse a cualquier tipo de objeto (incluso a funciones).</p><pre><code class=language-python>def echo(value):
    return value

a = echo

a(‘Billy’) # 3
</code></pre><h2 id=namespace-espacio-de-nombres>Namespace (espacio de nombres)<a class=anchor href=#namespace-espacio-de-nombres>#</a></h2><p>Para ponerlo en palabras llanas, un namespace es simplemente un conjunto de names.</p><p>En Python, te puedes imaginar que existe una relación que liga a los nombres definidos con sus respectivos objetos (como un diccionario). Pueden coexistir varios namespaces en un momento dado, pero se encuentran completamente aislados. Por ejemplo, existe un namespace específico que agrupa todas las variables globales (por eso puedes utilizar varias funciones sin tener que importar los módulos correspondientes) y cada vez que declaramos una módulo o una función, dicho módulo o función tiene asignado otro namespace.</p><p>A pesar de existir una multiplicidad de namespaces, no siempre tenemos acceso a todos ellos desde un punto específico en nuestro programa. Es aquí donde el concepto de scope (campo de aplicación o alcance) entra en juego.</p><h2 id=scope-alcance>Scope (alcance)<a class=anchor href=#scope-alcance>#</a></h2><p>Es la parte del programa en el que podemos tener acceso a un namespace sin necesidad de prefijos.</p><p>En cualquier momento determinado, el programa tiene acceso a tres scopes:</p><ul><li>El scope dentro de una función (que tiene nombres locales)</li><li>El scope del módulo (que tiene nombres globales)</li><li>El scope raíz (que tiene los built-in names)</li></ul><p>Cuando se solicita un objeto, Python busca primero el nombre en el scope local, luego en el global, y por último, en el raíz. Cuando anidamos una función dentro de otra función, su scope también queda anidado dentro del scope de la función padre.</p><pre><code class=language-python>def outer_function(some_local_name):
    def inner_function(other_local_name):
         # Tiene acceso a la built-in function print y al nombre local some_local_name
         print(some_local_name) 
        
         # También tiene acceso a su scope local
         print(other_local_name)
</code></pre><p>Para poder manipular una variable que se encuentra fuera del scope local podemos utilizar los keywords global y nonlocal.</p><pre><code class=language-python>some_var_in_other_scope = 10

def some_function():
     global some_var_in_other_scope
     
     Some_var_in_other_scope += 1
</code></pre><h1 id=errors-errores>Errors (Errores)</h1><p>Un programa de Python termina en cuanto encuentra un error. Es diferente a un error de sintaxis(pues en el error de sintaxis el codigo no llega a compilar).</p><p>Por lo tanto es una buena practicar que manejemos los posibles errores que puedan llegar a suceder en nuestro codigo. Esto lo hacemos &ldquo;aventando&rdquo; excepciones o errores.</p><p>Para “aventar” un error utilizamos el keyword raise.
Ej.</p><pre><code class=language-python>def divide(numerator, denominator):

If denominator == 0:
raise ZeroDivisionError
</code></pre><p>También podemos generar nuestros propios error, si extendemos <em>BaseException</em>
Ej.</p><p><code>class TakeOffError(BaseException)</code></p><p>Si queremos evitar que termine el programa y tenemos una estrategia para responder al error podemos utilizar los keyword <strong>try</strong> / <strong>except</strong>
Ej.</p><pre><code class=language-python>try:
	airplane.takeoff()
except TakeOffError as error:
	airplane.land()
</code></pre><p>El esqueleto de una estructura <strong>try</strong> es:</p><pre><code class=language-python>try:
	#run this code
except
	#execute this code when there is an exception
else:
	#no exception? run this code
finally:
	#allways run this code			
</code></pre><p>Si desea conoces mas acerca de los errores y como manejarlos visita el <a href=URL title=https://docs.python.org/3/tutorial/errors.html>web site oficial</a></p><h1 id=context-managers>Context Managers</h1><p>Son objetos de Python que proveen información contextual adicional al bloque de código. Esta información consiste en correr una función (o cualquier callable) cuando se inicia el contexto con el keyword with; al igual que correr otra función cuando el código dentro del bloque with concluye. Por ejemplo:</p><pre><code class=language-python>with open(‘some_file.txt’) as f:
    lines = f.readlines()
</code></pre><p>Si estás familiarizado con este patrón, sabes que llamar la función open de esta manera, garantiza que el archivo se cierre con posterioridad. Esto disminuye la cantidad de información que el programador debe manejar directamente y facilita la lectura del código.</p><p>Existen dos formas de <em>implementar</em> un context manager:</p><ul><li>Con una clase.</li><li>Con un generador.</li></ul><p>Vamos a implementar la funcionalidad anterior para ilustrar el punto:</p><pre><code class=language-python>class CustomOpen(object):
    def __init__(self, filename):
        self.file = open(filename)

    def __enter__(self):
        return self.file

    def __exit__(self, ctx_type, ctx_value, ctx_traceback):
        self.file.close()

with CustomOpen('file') as f:
    contents = f.read()
</code></pre><p>Esta es simplemente una clase de Python con <strong>dos métodos</strong> adicionales: <em><strong>enter y exit</strong></em>. Estos métodos son utilizados por el keyword with para determinar las acciones de inicialización, entrada y salida del contexto.</p><p>El mismo código puede implementarse utilizando el módulo <strong>contextlib</strong> que forma parte de la librería estándar de Python.</p><pre><code class=language-python>from contextlib import contextmanager

@contextmanager
def custom_open(filename):
    f = open(filename)
    try:
        yield f
    finally:
        f.close()

with custom_open('file') as f:
    contents = f.read()
</code></pre><p>El código anterior funciona exactamente igual que cuando lo escribimos con una clase. La diferencia es que el código se ejecuta al inicializarse el contexto y retorna el control cuando el keyword yield regresa un valor. Una vez que termina el bloque with, el context manager toma de nueva cuenta el control y ejecuta el código de limpieza.</p><h1 id=pypi-python-package-index>PyPi (Python Package Index)</h1><p>Es un repositorio de paquetes de 3º. Para instalar un nuevo paquete es necesario utilizar la herramienta <strong>PIP</strong> ejecutando el comando:</p><p><code>Pip install package_name</code></p><p>Tambien se puede agrupar la instalacion de varios paquetes en requerements.txt(como una especia de receta, como el DockerFile.yml de docker o el composer.json de PHP) de la siguiente manera:</p><pre><code>Package_name_1 == Version
Package_name_2 == Version
Package_name_3 == Version
</code></pre><p>Para la instalacion de pip descarga el siguiente <a href=URL title=https://bootstrap.pypa.io/get-pip.py>script</a>, y ejecutalo. Para mayor informacion puedes visitar el <a href=URL title=https://pypi.org/project/pip/>web site oficial</a> de pip</p><h1 id=ambientes-virtuales>Ambientes Virtuales</h1><p>Son como una especie de &ldquo;contenedores&rdquo; en los cuales podemos trabajar sin interactuar con el interprete global de python.</p><p>Es una buena pracitca crear ambientes virtuales para cada proyecto de python en el que estamos trabajando. Esto nos evitara posibles conflictos en paquetes.</p><p>los pasos para crear un ambiente virtual son :</p><ol><li><p>Tener instalado virtualenv:
Esto lo realizamos con <strong>pip</strong> desde nuestro interprete global.
<code>pip install virtualenv</code></p></li><li><p>crear el entorno virtual:
<code>virtualenv venv</code></p></li><li><p>Activar el entorno virtual:
<code>source venv/bin/active</code></p></li></ol><p>Para desactivar el entorno virtual solo utilizamos:
<code>desactive</code></p><h1 id=peps-python-enhancement-proposals>PEPs (Python Enhancement Proposals)</h1><p>Describen cambios al lenguaje o a los estándares alrededor</p><p>Pueden ser de tres tipos:</p><ul><li><p><strong>Standards</strong>: Describen un nuevo feature o comportamiento.</p></li><li><p><strong>Informational</strong>: Describen un problema de diseño, una guía general, o información
para la comunidad.</p></li><li><p><strong>Process</strong>: Describen un proceso relacionado con Python, pero no al código
fuente de Python.
Ej. cambios en los procesos de toma de decisiones</p></li></ul><p><strong>PEPs</strong></p><ul><li><strong>PEP8</strong>: Python style guide.</li><li><strong>PEP257</strong>: Python docstrings.</li><li><strong>PEP20</strong>: import this.</li></ul><p><a href=https://www.python.org/dev/peps/>https://www.python.org/dev/peps/</a></p><h1 id=unit-testing>Unit Testing</h1><h2 id=doctest>Doctest<a class=anchor href=#doctest>#</a></h2><p>Las pruebas unitarias son un conjunto de pruebas que le ofrecen a nuestra aplicacion ser mas robusta.</p><p>En el stack de python viene incluido el modulo de doctest. Este nos permitira realizar pruebas unitarias de una manera muy sencilla. Para ello en un archivo tipeamos nuestras operaciones de la siguiente manera:</p><pre><code class=language-python>&gt;&gt;&gt; 2 + 2
4

&gt;&gt;&gt; 3*3 != 10
True
</code></pre><p>Suponiendo que el archivo se llama <em>test.txt</em> lo ejecutamos de la siguiente manera: <code>python3 -m doctest test.txt</code>. De esta manera ejecutamos las pruebas en nestro archivo.</p><p>Tambien podemos realizar nuestros tests directamente en el DocString de nuestras funciones o metodos.</p><pre><code class=language-python>&quot;&quot;&quot;
from functools import lru_cache

@lru_cache()
def fibonacci(number):
    &quot;&quot;&quot;
    Retorn el numero n de la serie de fibonacci dado un n number
        &gt;&gt;&gt; fibonacci(5)
        5

        &gt;&gt;&gt; fibonacci(11)
        89

    &quot;&quot;&quot;
    if number &lt;= 1:
        return number, number
    return (fibonacci(number-1)[0] + fibonacci(number-2)[0]), number
if __name__ == '__main__':
    fibonacci(200)
    print('Informacion del cache: ', fibonacci.cache_info())
    # Para limpiar la cache en caso de que lo deseemos aplicamos el metodo fibonacci.cache_clear()
</code></pre><p>Para testearlo aplicamos el mismo comando. <code>python3 -m doctest fibonacci.py</code></p><p>Podemos realizar tarea bastante complejas y que requieran varias instrucciones. Para ellos nos podemos apoyar de un fichero como el del primer ejemplo.</p><h2 id=asserts>Asserts<a class=anchor href=#asserts>#</a></h2><p>Este es un feature de python que nos permite validar y testear nuestro codigo de una manera sencilla. Aca, evaluaremos una expresion y siempre que esta nos retorne False se le vantara una Exception de tipo AssertionError. Ejemplo:</p><pre><code class=language-python>assert True
assert False, 'Este es el mensaje de la Exception'
AssertionError: Este es el mensaje de la Exception
</code></pre><h2 id=otros>Otros<a class=anchor href=#otros>#</a></h2><p>Adicionalmente existe la libreria <a href=https://docs.pytest.org/en/latest>pytest</a> y el framework <a href=https://docs.python.org/3/library/unittest.html>unittest</a>. Se recomienda la utlizacion del segundo, ya que es mas robusto.</p><h2 id=covertura>Covertura<a class=anchor href=#covertura>#</a></h2><p>La covertura es utilizada para ver que porcentaje de nuestro codigo se esta ejecutando, con nuestras Pruebas unitarias. Si se esta ejecutando el 100%. Esto indica que nuestro codigo no deberia tener fallas(Logicamente si paso todos los test).</p><p>Para realizar esto nos vamos a apoyar de la libreria <a href=https://coverage.readthedocs.io/en/coverage-5.0.4/>coverage</a></p><p>Una vez intalada. Ejecutamos las siguiente lineas de codigo</p><pre><code class=language-zsh>coverage run test.py #Suponiendo que el fichero test.py se encuentran nuestras pruebas unitarias de nuestro script.py

coverage report -m script.py #Esto nos mostrara un reporte con: Lineas totales, Lineas no ejecutadas, Porcentaje de lineas no ejecutadas, Numero de las lineas que no fueron ejecutas.

coverage html script.py # Esto nos  creara un reporte en un archivo html
</code></pre><p>PD: Los reportes creados en archivos html deben observarse desde un servidor web. El comando <code>python3 -m http.server</code> nos ayudara con esto.</p><h1 id=manejo-de-imagenes>Manejo de imagenes</h1><p>Una libreria muy conocida en python para el manejo de imagenes es <a href=https://pypi.org/project/Pillow/>PIL</a></p><h1 id=cómo-seguir>Cómo seguir</h1><p>Python tiene muchas aplicaciones:</p><p>En las ciencias tiene muchas librerías que puedes utilizar como analisis de las estrellas y astrofisica; si te interesa la medicina puedes utilizar <strong>Tomopy</strong> para analizar tomografías. También están las librerías más fuertes para la ciencia de datos <strong>numpy, Pandas y Matplotlib</strong></p><p>En <strong>CLI</strong> por si te gusta trabajar en la nube y con datacenters, para sincronizar miles de computadoras:</p><ul><li>aws</li><li>gocloud</li><li>rebound</li><li>geeknote</li></ul><p><strong>Aplicaciones Web</strong>:</p><ul><li>Django</li><li>Flask</li><li>Bottle</li><li>Chalice</li><li>Webapp2</li><li>Gunicorn</li><li>Tornado</li></ul><h1 id=zen-de-python>ZEN de Python</h1><p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren&rsquo;t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one&ndash; and preferably only one &ndash;obvious way to do it.<br>Although that way may not be obvious at first unless you&rsquo;re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it&rsquo;s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea &ndash; let&rsquo;s do more of those!</p></article><div class=pagination><a class=pagination__item href=https:///jmillandev.github.io/apuntes/readme/><span class=pagination__label>Previous Post</span>
<span class=pagination__title></span></a><a class=pagination__item href=https:///jmillandev.github.io/apuntes/oop/><span class=pagination__label>Next Post</span>
<span class=pagination__title></a></a></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"jmillandev"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=post__footer><div class=social-icons><a class=social-icons__link title=Twitter href=https://twitter.com/jmillandev target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/twitter.svg)></div></a><a class=social-icons__link title=GitHub href=https://github.com/jmillandev target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/github.svg)></div></a><a class=social-icons__link title=LinkedIn href=https://www.linkedin.com/in/jmillandev-42664412a/ target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https:///jmillandev.github.io/svg/linkedin.svg)></div></a></div><p>© 2022</p></footer></div></div></div></main><script src=/jmillandev.github.io/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr+kQ=" crossorigin=anonymous></script><script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script><script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script></body></html>